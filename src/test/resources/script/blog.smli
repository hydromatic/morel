(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *
 * This script contains Morel fragments that are used in Morel's
 * web site, documentation, and blog posts. Just, you know, to keep
 * us honest.
 *)
Sys.set ("printDepth", ~1);
> val it = () : unit
Sys.set ("lineWidth", 78);
> val it = () : unit
Sys.set ("stringDepth", ~1);
> val it = () : unit

(*) === README.md ===================================================

(*) Auxiliary declarations
val e = {deptno = 10, name = "Fred"};
> val e = {deptno=10,name="Fred"} : {deptno:int, name:string}
val d = 10;
> val d = 10 : int
val filter = List.filter;
> val filter = fn : ('a -> bool) -> 'a list -> 'a list

"Hello, world!";
> val it = "Hello, world!" : string

(*) In Morel, you can omit label = if the expression is an identifier,
(*) label application, or field reference. Thus
{#deptno e, e.name, d};
> val it = {d=10,deptno=10,name="Fred"} : {d:int, deptno:int, name:string}
(*) is shorthand for
{deptno = #deptno e, name = e.name, d = d};
> val it = {d=10,deptno=10,name="Fred"} : {d:int, deptno:int, name:string}

(*) In a sense, from is syntactic sugar. For example, given emps and
(*) depts, relations defined as lists of records as follows
val emps =
  [{id = 100, name = "Fred", deptno = 10},
   {id = 101, name = "Velma", deptno = 20},
   {id = 102, name = "Shaggy", deptno = 30},
   {id = 103, name = "Scooby", deptno = 30}];
> val emps =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list
val depts =
  [{deptno = 10, name = "Sales"},
   {deptno = 20, name = "Marketing"},
   {deptno = 30, name = "Engineering"},
   {deptno = 40, name = "Support"}];
> val depts =
>   [{deptno=10,name="Sales"},{deptno=20,name="Marketing"},
>    {deptno=30,name="Engineering"},{deptno=40,name="Support"}]
>   : {deptno:int, name:string} list
(*) the expression
from e in emps where e.deptno = 30 yield e.id;
> val it = [102,103] : int list
(*) is equivalent to standard ML
map (fn e => (#id e)) (filter (fn e => (#deptno e) = 30) emps);
> val it = [102,103] : int list

(*) You can iterate over more than one collection, and therefore
(*) generate a join or a cartesian product:
from e in emps, d in depts
  where e.deptno = d.deptno
  yield {e.id, e.deptno, ename = e.name, dname = d.name};
> val it =
>   [{deptno=10,dname="Sales",ename="Fred",id=100},
>    {deptno=20,dname="Marketing",ename="Velma",id=101},
>    {deptno=30,dname="Engineering",ename="Shaggy",id=102},
>    {deptno=30,dname="Engineering",ename="Scooby",id=103}]
>   : {deptno:int, dname:string, ename:string, id:int} list
(*) As in any ML expression, you can define functions within a from
(*) expression, and those functions can operate on lists. Thus we can
(*) implement equivalents of SQL's IN and EXISTS operators:
(* FIXME
let
  fun in_ e [] = false
    | in_ e (h :: t) = e = h orelse (in_ e t)
in
  from e in emps
  where in_ e.deptno (from d in depts
                where d.name = "Engineering"
                yield d.deptno)
  yield e.name
end;
*)
(* FIXME
let
  fun exists [] = false
    | exists hd :: tl = true
in
  from e in emps
  where exists (from d in depts
                where d.deptno = e.deptno
                andalso d.name = "Engineering")
  yield e.name
end;
*)

(*) === Screen cast =================================================

(*) Now we're in morel's shell, for interactive commands.
(*) First of all, we need to talk about comments.

(* This is a block comment, which can span multiple lines... *)

(*) ... and this is a single-line comment.

(*) Now, the basics.
(*) Everything in ML is an expression.
"a string literal";
> val it = "a string literal" : string
1 + 2;
> val it = 3 : int

(*) The Morel shell deduces the type of each expression,
(*) and assigns it to a variable called "it".
(*) We can use "it" in the next expression...
it + 4;
> val it = 7 : int

(*) We just saw string and int expressions.
(*) There are also boolean, list, record and tuple types:
1 = 2;
> val it = false : bool
[1, 2, 3];
> val it = [1,2,3] : int list
{id = 10, name = "Alex"};
> val it = {id=10,name="Alex"} : {id:int, name:string}
(1, true, "yes");
> val it = (1,true,"yes") : int * bool * string

(*) You can assign values to variables.
val x = 7;
> val x = 7 : int
val y =  x mod 3;
> val y = 1 : int

(*) Functions are expressions, too.
(*) "fn" makes a lambda expression.
val plusOne = fn x => x + 1;
> val plusOne = fn : int -> int
plusOne 2;
> val it = 3 : int

(*) Functions are widely used, so they have a shorthand.
(*) "fun" is short for "val ... = fn".
fun plusOne x = x + 1;
> val plusOne = fn : int -> int
plusOne 1000;
> val it = 1001 : int

(*) Functions can have multiple arguments, separated by spaces.
fun plus x y = x + y;
> val plus = fn : int -> int -> int
plus 3 4;
> val it = 7 : int

(*) If we supply too few arguments, we get a closure that captures
(*) the argument value and can be applied later.
val plusTen = plus 10;
> val plusTen = fn : int -> int
plusTen 2;
> val it = 12 : int

(*) Functions can be recursive.
fun fact n = if n = 1 then 1 else n * fact (n - 1);
> val fact = fn : int -> int
fact 1;
> val it = 1 : int
fact 5;
> val it = 120 : int

(*) A higher-order function is a function that operates on other
(*) functions. Here are a couple.

(*) "map" applies another function to each element of a list
let
  fun map f [] = []
    | map f (head :: tail) = (f head) :: (map f tail)
  fun double n = n * 2
in
  map double [1, 2, 3, 4]
end;
> val it = [2,4,6,8] : int list

(*) "filter" keeps only those elements of a list for which
(*) a predicate evaluates to true.
let
  fun filter p [] = []
    | filter p (head :: tail) =
      if (p head) then
        (head :: (filter p tail))
      else
        (filter p tail)
  fun even n = n mod 2 = 0
in
  filter even [1, 2, 3, 4]
end;
> val it = [2,4] : int list

(*) You may notice that "map" and "filter" are very similar to the
(*) "select" and "where" clauses of a SQL statement.
(*)
(*) This is no surprise: relational algebra, which underlies SQL, is
(*) basically a collection of higher-order functions applied to
(*) lists of records (relations).
(*)
(*) Can we extend ML syntax to make it easier to write relational
(*) algebra expressions? You bet!

(*) Let's start by defining "emp" and "dept" relations as lists of
(*) records.
val emps =
  [{id = 100, name = "Fred", deptno = 10},
   {id = 101, name = "Velma", deptno = 20},
   {id = 102, name = "Shaggy", deptno = 30},
   {id = 103, name = "Scooby", deptno = 30}];
> val emps =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list
val depts =
  [{deptno = 10, name = "Sales"},
   {deptno = 20, name = "HR"},
   {deptno = 30, name = "Engineering"},
   {deptno = 40, name = "Support"}];
> val depts =
>   [{deptno=10,name="Sales"},{deptno=20,name="HR"},
>    {deptno=30,name="Engineering"},{deptno=40,name="Support"}]
>   : {deptno:int, name:string} list

(*) Now our first query, equivalent to "select * from emps as e".
from e in emps yield e;
> val it =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list

(*) Now "select e.id from emps as e where e.deptno = 30"
from e in emps where (#deptno e) = 30 yield (#id e);
> val it = [102,103] : int list

(*) Join two relations
from e in emps, d in depts
  where (#deptno e) = (#deptno d)
  yield {id = (#id e), deptno = (#deptno e),
         ename = (#name e), dname = (#name d)};
> val it =
>   [{deptno=10,dname="Sales",ename="Fred",id=100},
>    {deptno=20,dname="HR",ename="Velma",id=101},
>    {deptno=30,dname="Engineering",ename="Shaggy",id=102},
>    {deptno=30,dname="Engineering",ename="Scooby",id=103}]
>   : {deptno:int, dname:string, ename:string, id:int} list

(*) A query with "exists" and a correlated sub-query.
(*) We define the "exists" function ourselves: no need for a
(*) built-in!
let
  fun exists [] = false
    | exists (head :: tail) = true
in
  from e in emps
    where exists (from d in depts
                  where (#deptno d) = (#deptno e)
                  andalso (#name d) = "Engineering")
    yield (#name e)
end;
> val it = ["Shaggy","Scooby"] : string list

(*) That's all, folks!
(*) To recap, Morel has:
(*)  * expressions of int, string, boolean, float, char, list,
(*)    tuple and record types;
(*)  * lambda expressions and recursive functions;
(*)  * algebraic datatypes and pattern-matching;
(*)  * polymorphism and powerful type-inference;
(*)  * relational expressions (an extension to Standard ML).
(*)
(*) Follow our progress at https://github.com/hydromatic/morel.
(*) This is only release 0.1, so there's more to come!

(*) === 2020/02/25: Morel: A functional language for data ===========

(*) Auxiliary declarations
val hr = {
  emps = [
    {id = 100, deptno = 10, name = "SCOTT"}],
  depts = [
    {deptno = 10, name = "SALES"}]};
> val hr =
>   {depts=[{deptno=10,name="SALES"}],emps=[{deptno=10,id=100,name="SCOTT"}]}
>   : {depts:{deptno:int, name:string} list,
>      emps:{deptno:int, id:int, name:string} list}

(*) here is a query in Morel:
from e in hr.emps,
    d in hr.depts
where e.deptno = d.deptno
yield {e.id, e.deptno, ename = e.name, dname = d.name};
> val it = [{deptno=10,dname="SALES",ename="SCOTT",id=100}]
>   : {deptno:int, dname:string, ename:string, id:int} list

(*) === 2020/03/03: Morel: The basic language =======================

(* As a functional language, everything in Morel is an expression.
The basic types are `bool`, `int`, `float`, `string` and `char`.  Here
are literals in each. *)
false;
> val it = false : bool
10;
> val it = 10 : int
~4.5;
> val it = ~4.5 : real
"morel";
> val it = "morel" : string
#"a";
> val it = #"a" : char
();
> val it = () : unit

(* As you'd expect, there are built-in operators for each data
type. Here are a few examples: *)
true andalso false;
> val it = false : bool
true orelse false;
> val it = true : bool
not false;
> val it = true : bool
1 + 2;
> val it = 3 : int
~(5 - 2);
> val it = ~3 : int
10 mod 3;
> val it = 1 : int
"mo" ^ "rel";
> val it = "morel" : string

(* You can assign values to variables. *)
val x = 7;
> val x = 7 : int
val y = x mod 3;
> val y = 1 : int
x + y;
> val it = 8 : int

(* The shell deduces the type of each expression,
   and assigns it to a variable called `it`.
   We can use `it` in the next expression. *)
"morel";
> val it = "morel" : string
String.size it;
> val it = 5 : int
it + 4;
> val it = 9 : int

(* A let expression binds one or more values and evaluates an expression *)
let
  val x = 3
  val y = 2
in
  x + y
end;
> val it = 5 : int

(* In addition to primitive types, there are list, record and tuple
   types. *)
[1, 2, 3];
> val it = [1,2,3] : int list
{id = 10, name = "Scooby"};
> val it = {id=10,name="Scooby"} : {id:int, name:string}
(1, true, "yes");
> val it = (1,true,"yes") : int * bool * string

(* Tuples are actually just records with fields named "1", "2",
   etc.: *)
(1, true, "yes");
> val it = (1,true,"yes") : int * bool * string
{1 = 1, 2 = true, 3 = "yes"};
> val it = (1,true,"yes") : int * bool * string
(1, true, "yes") = {1 = 1, 2 = true, 3 = "yes"};
> val it = true : bool

(* The empty record and empty tuple are equal, and are the only value
   of the type unit. *)
{};
> val it = () : unit
();
> val it = () : unit
{} = ();
> val it = true : bool

(* Functions are expressions, too.  `fn` makes a lambda expression.
   After we have bound the lambda value to `plusOne`, we can use
   `plusOne` as a function. *)
val plusOne = fn x => x + 1;
> val plusOne = fn : int -> int
plusOne 2;
> val it = 3 : int

(* Functions declarations are common, so the `fun` keyword provides a
   shorthand. *)
fun plusOne x = x + 1;
> val plusOne = fn : int -> int
plusOne 2;
> val it = 3 : int

(* Functions can have multiple arguments, separated by spaces. *)
fun plus x y = x + y;
> val plus = fn : int -> int -> int
plus 3 4;
> val it = 7 : int

(* If we supply too few arguments, we get a closure that captures the
   argument value and can be applied later. *)
val plusTen = plus 10;
> val plusTen = fn : int -> int
plusTen 2;
> val it = 12 : int

(* Functions can be recursive. *)
fun factorial n =
  if n = 1 then
    1
  else
     n * factorial (n - 1);
> val factorial = fn : int -> int
factorial 1;
> val it = 1 : int
factorial 5;
> val it = 120 : int

(* A higher-order function is a function that operates on other
   functions. Here are a couple of examples.

   The map function applies a given function `f` to each element of a
   list, returning a list. *)
fun map f [] = []
  | map f (head :: tail) = (f head) :: (map f tail);
> val map = fn : ('a -> 'b) -> 'a list -> 'b list
fun double n = n * 2;
> val double = fn : int -> int
map double [1, 2, 3, 4];
> val it = [2,4,6,8] : int list

(* The filter function keeps only those elements of a list for which a
   predicate `p` evaluates to true. *)
fun filter p [] = []
  | filter p (head :: tail) =
    if (p head) then
      (head :: (filter p tail))
    else
      (filter p tail);
> val filter = fn : ('a -> bool) -> 'a list -> 'a list
fun even n = n mod 2 = 0;
> val even = fn : int -> bool
filter even [1, 2, 3, 4];
> val it = [2,4] : int list

(* Let’s start by defining emps and depts relations as lists of
   records. *)

val emps =
  [{id = 100, name = "Fred", deptno = 10},
   {id = 101, name = "Velma", deptno = 20},
   {id = 102, name = "Shaggy", deptno = 30},
   {id = 103, name = "Scooby", deptno = 30}];
> val emps =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list
val depts =
  [{deptno = 10, name = "Sales"},
   {deptno = 20, name = "HR"},
   {deptno = 30, name = "Engineering"},
   {deptno = 40, name = "Support"}];
> val depts =
>   [{deptno=10,name="Sales"},{deptno=20,name="HR"},
>    {deptno=30,name="Engineering"},{deptno=40,name="Support"}]
>   : {deptno:int, name:string} list

(* Now let's run our first query. *)
from e in emps yield e;
> val it =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list

(* There is no difference between a query, a table and a list-valued
   expression, so we could have instead written just `emps`. *)
emps;
> val it =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list

(* A where clause filters out rows. *)
from e in emps
  where #deptno e = 30
  yield {id = #id e};
> val it = [{id=102},{id=103}] : {id:int} list

(* The following is equivalent. *)
from e in emps
  where e.deptno = 30
  yield {e.id};
> val it = [{id=102},{id=103}] : {id:int} list

(* If you omit 'yield' you get the raw values of 'e'. *)
from e in emps
  where #deptno e = 30;
> val it = [{deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list

(* Shorthand. The following 3 queries are equivalent. *)
from e in emps
  yield {e = #id e};
> val it = [{e=100},{e=101},{e=102},{e=103}] : {e:int} list
from e in emps
  yield {e = e.id};
> val it = [{e=100},{e=101},{e=102},{e=103}] : {e:int} list
from e in emps
  yield {e.id};
> val it = [{id=100},{id=101},{id=102},{id=103}] : {id:int} list

(* Joins and sub-queries. *)
from e in emps,
    d in depts
  where e.deptno = d.deptno
  yield {e.id, e.deptno, ename = e.name, dname = d.name};
> val it =
>   [{deptno=10,dname="Sales",ename="Fred",id=100},
>    {deptno=20,dname="HR",ename="Velma",id=101},
>    {deptno=30,dname="Engineering",ename="Shaggy",id=102},
>    {deptno=30,dname="Engineering",ename="Scooby",id=103}]
>   : {deptno:int, dname:string, ename:string, id:int} list

(* The following query would, in SQL, be described as having 'EXISTS
   and a correlated sub-query'. But 'exists' is not a built-in keyword
   in Morel, just a function that we define in the query, and a
   sub-query is just an expression that happens to return a list. *)
let
  fun exists [] = false
    | exists (head :: tail) = true
in
  from e in emps
    where exists (from d in depts
                  where d.deptno = e.deptno
                  andalso d.name = "Engineering")
    yield e.name
end;
> val it = ["Shaggy","Scooby"] : string list

(*) === 2020/03/03: Morel: The basic language =======================

(*) WordCount in Standard ML
(* Note: The blog post used Standard ML. Here, to accommodate missing
   language features in Morel, we have changed "(op +)" to
   "(fn (x, y) => x + y)". *)
fun mapReduce mapper reducer list =
  let
    fun update (key, value, []) = [(key, [value])]
      | update (key, value, ((key2, values) :: tail)) =
          if key = key2 then
            (key, (value :: values)) :: tail
          else
            (key2, values) :: (update (key, value, tail))
    fun dedup ([], dict) = dict
      | dedup ((key, value) :: tail, dict) =
          dedup (tail, update (key, value, dict))
    fun flatMap f list = List.foldl List.at [] (List.map f list)
    val keyValueList = flatMap mapper list
    val keyValuesList = dedup (keyValueList, [])
  in
    List.map (fn (key, values) => (key, reducer (key, values))) keyValuesList
  end;
> val mapReduce = fn
>   : ('a -> ('b * 'c) list) ->
>      ('b * 'c list -> 'd) -> 'a list -> ('b * 'd) list

fun wc_mapper line =
  let
    fun split0 [] word words = word :: words
      | split0 (#" " :: s) word words = split0 s "" (word :: words)
      | split0 (c :: s) word words = split0 s (word ^ (String.str c)) words
    fun split s = List.rev (split0 (String.explode s) "" [])
  in
    List.map (fn w => (w, 1)) (split line)
  end;
> val wc_mapper = fn : string -> (string * int) list
fun wc_reducer (key, values) = List.foldl (fn (x, y) => x + y) 0 values;
> val wc_reducer = fn : 'a * int list -> int

(*) Check that they work on discrete values
wc_mapper "a skunk sat on a stump";
> val it = [("a",1),("skunk",1),("sat",1),("on",1),("a",1),("stump",1)]
>   : (string * int) list
wc_reducer ("hello", [1, 4, 2]);
> val it = 7 : int

(*) Bind them to mapReduce, and run
fun wordCount lines = mapReduce wc_mapper wc_reducer lines;
> val wordCount = fn : string list -> (string * int) list
from p in wordCount ["a skunk sat on a stump",
    "and thunk the stump stunk",
    "but the stump thunk the skunk stunk"]
order p.word;
> stdIn:4.7 Error: no field 'word' in type 'string * int'
>   raised at: stdIn:4.7
from p in wordCount ["a skunk sat on a stump",
    "and thunk the stump stunk",
    "but the stump thunk the skunk stunk"]
order #1 p;
> val it =
>   [("a",2),("and",1),("but",1),("on",1),("sat",1),("skunk",2),("stump",3),
>    ("stunk",2),("the",3),("thunk",2)] : (string * int) list

(*) WordCount in Morel
val lines = ["a skunk sat on a stump",
  "and thunk the stump stunk",
  "but the stump thunk the skunk stunk"];
> val lines =
>   ["a skunk sat on a stump","and thunk the stump stunk",
>    "but the stump thunk the skunk stunk"] : string list
fun split s =
  let
    fun split0 [] word words = word :: words
      | split0 (#" " :: s) word words = split0 s "" (word :: words)
      | split0 (c :: s) word words = split0 s (word ^ (String.str c)) words
  in
    List.rev (split0 (String.explode s) "" [])
  end;
> val split = fn : string -> string list
from line in lines,
    word in split line
  group word compute count
  order word;
> val it =
>   [{count=2,word="a"},{count=1,word="and"},{count=1,word="but"},
>    {count=1,word="on"},{count=1,word="sat"},{count=2,word="skunk"},
>    {count=3,word="stump"},{count=2,word="stunk"},{count=3,word="the"},
>    {count=2,word="thunk"}] : {count:int, word:string} list

(*) A more complete solution
fun wordCount lines =
  let
    fun split0 [] word words = word :: words
      | split0 (#" " :: s) word words = split0 s "" (word :: words)
      | split0 (c :: s) word words = split0 s (word ^ (String.str c)) words
    fun split s = List.rev (split0 (String.explode s) "" [])
  in
    from line in lines,
        word in split line
    group word compute count
  end;
> val wordCount = fn : string list -> {count:int, word:string} list
from p in wordCount lines order p.word;
> val it =
>   [{count=2,word="a"},{count=1,word="and"},{count=1,word="but"},
>    {count=1,word="on"},{count=1,word="sat"},{count=2,word="skunk"},
>    {count=3,word="stump"},{count=2,word="stunk"},{count=3,word="the"},
>    {count=2,word="thunk"}] : {count:int, word:string} list

(*) === Aggregate functions =========================================

val emps = scott.emp;
> val emps = <relation>
>   :
>     {comm:real, deptno:int, empno:int, ename:string, hiredate:string,
>      job:string, mgr:int, sal:real} list
val depts = scott.dept;
> val depts = <relation> : {deptno:int, dname:string, loc:string} list

from e in emps
  group e.deptno compute sumSal = sum of e.sal
  order deptno;
> val it =
>   [{deptno=10,sumSal=8750.0},{deptno=20,sumSal=10875.0},
>    {deptno=30,sumSal=9400.0}] : {deptno:int, sumSal:real} list

from e in emps,
    d in depts
  where e.deptno = d.deptno
  group e.deptno, d.dname, e.job
    compute sumSal = sum of e.sal,
      minRemuneration = min of e.sal + e.comm
  order deptno, job;
> val it =
>   [
>    {deptno=10,dname="ACCOUNTING",job="CLERK",minRemuneration=1300.0,
>     sumSal=1300.0},
>    {deptno=10,dname="ACCOUNTING",job="MANAGER",minRemuneration=2450.0,
>     sumSal=2450.0},
>    {deptno=10,dname="ACCOUNTING",job="PRESIDENT",minRemuneration=5000.0,
>     sumSal=5000.0},
>    {deptno=20,dname="RESEARCH",job="ANALYST",minRemuneration=3000.0,
>     sumSal=6000.0},
>    {deptno=20,dname="RESEARCH",job="CLERK",minRemuneration=800.0,sumSal=1900.0},
>    {deptno=20,dname="RESEARCH",job="MANAGER",minRemuneration=2975.0,
>     sumSal=2975.0},
>    {deptno=30,dname="SALES",job="CLERK",minRemuneration=950.0,sumSal=950.0},
>    {deptno=30,dname="SALES",job="MANAGER",minRemuneration=2850.0,sumSal=2850.0},
>    {deptno=30,dname="SALES",job="SALESMAN",minRemuneration=1500.0,
>     sumSal=5600.0}]
>   : {deptno:int, dname:string, job:string, minRemuneration:real, sumSal:real} list

(*) In this example, we define our own version of the `sum` function:
let
  fun my_sum [] = 0
    | my_sum (head :: tail) = head + (my_sum tail)
in
  from e in emps
    group e.deptno
    compute sumEmpno = my_sum of e.empno
    order deptno
end;
> val it =
>   [{deptno=10,sumEmpno=23555},{deptno=20,sumEmpno=38501},
>    {deptno=30,sumEmpno=46116}] : {deptno:int, sumEmpno:int} list

(*) The equivalent of SQL's COLLECT aggregate function is trivial
from e in emps
  group e.deptno
  compute names = (fn x => x) of e.ename
  order deptno;
> val it =
>   [{deptno=10,names=["CLARK","KING","MILLER"]},
>    {deptno=20,names=["SMITH","JONES","SCOTT","ADAMS","FORD"]},
>    {deptno=30,names=["ALLEN","WARD","MARTIN","BLAKE","TURNER","JAMES"]}]
>   : {deptno:int, names:string list} list

(*) === StrangeLoop 2021 talk =======================================
(*) Standard ML: values
"Hello, world!";
> val it = "Hello, world!" : string
1 + 2;
> val it = 3 : int
~1.5;
> val it = ~1.5 : real
[1, 1, 2, 3, 5];
> val it = [1,1,2,3,5] : int list
fn i => i mod 2 = 1;
> val it = fn : int -> bool
(1, "a");
> val it = (1,"a") : int * string
{name = "Fred", empno = 100};
> val it = {empno=100,name="Fred"} : {empno:int, name:string}

(*) Standard ML: types
true;
> val it = true : bool
#"a";
> val it = #"a" : char
~1;
> val it = ~1 : int
3.14;
> val it = 3.14 : real
"foo";
> val it = "foo" : string
();
> val it = () : unit
String.size;
> val it = fn : string -> int
fn (x, y) => x + y * y;
> val it = fn : int * int -> int
(10, "Fred");
> val it = (10,"Fred") : int * string
{empno=10, name="Fred"};
> val it = {empno=10,name="Fred"} : {empno:int, name:string}
[1, 2, 3];
> val it = [1,2,3] : int list
[(true, fn i => i + 1)];
> val it = [(true,fn)] : (bool * (int -> int)) list
List.length;
> val it = fn : 'a list -> int

(*) Standard ML: variables and functions
val x = 1;
> val x = 1 : int
val isOdd = fn i => i mod 2 = 1;
> val isOdd = fn : int -> bool
fun isOdd i = i mod 2 = 0;
> val isOdd = fn : int -> bool
isOdd x;
> val it = false : bool
let
  val x = 6
  fun isOdd i = i mod 2 = 1
in
  isOdd x
end;
> val it = false : bool

(*) Algebraic data types, case, and recursion
(* TODO fix bug in parameterized datatype, and remove intTree below
datatype 'a tree =
    EMPTY
  | LEAF of 'a
  | NODE of ('a * 'a tree * 'a tree);
*)
datatype intTree =
    EMPTY
  | LEAF of int
  | NODE of (int * intTree * intTree);
> datatype intTree = EMPTY | LEAF of int | NODE of int * intTree * intTree
fun sumTree EMPTY = 0
  | sumTree (LEAF i) = i
  | sumTree (NODE (i, l, r)) =
        i + sumTree l + sumTree r;
> val sumTree = fn : intTree -> int
val t = NODE (1, LEAF 2, NODE (3, EMPTY, LEAF 7));
> val t = NODE (1,LEAF 2,NODE (3,EMPTY,LEAF 7)) : intTree
sumTree t;
> val it = 13 : int
val rec sumTree = fn t =>
  case t of EMPTY => 0
    | LEAF i => i
    | NODE (i, l, r) => i + sumTree l + sumTree r;
> val sumTree = fn : intTree -> int

(*) Relations and higher-order functions
val emps = [
  {id = 100, name = "Fred", deptno = 10},
  {id = 101, name = "Velma", deptno = 20},
  {id = 102, name = "Shaggy", deptno = 30},
  {id = 103, name = "Scooby", deptno = 30}];
> val emps =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list
List.filter (fn e => #deptno e = 30) emps;
> val it = [{deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list

(*) Implementing Join using higher-order functions
val depts = [
  {deptno = 10, name = "Sales"},
  {deptno = 20, name = "Marketing"},
  {deptno = 30, name = "R&D"}];
> val depts =
>   [{deptno=10,name="Sales"},{deptno=20,name="Marketing"},
>    {deptno=30,name="R&D"}] : {deptno:int, name:string} list
fun flatMap f xs = List.concat (List.map f xs);
> val flatMap = fn : ('a -> 'b list) -> 'a list -> 'b list
List.map
  (fn (d, e) => {deptno = #deptno d, name = #name e})
  (List.filter
    (fn (d, e) => #deptno d = #deptno e)
    (flatMap
      (fn e => (List.map (fn d => (d, e)) depts))
      emps));
> val it =
>   [{deptno=10,name="Fred"},{deptno=20,name="Velma"},{deptno=30,name="Shaggy"},
>    {deptno=30,name="Scooby"}] : {deptno:int, name:string} list

(*) Implementing Join in Morel using `from`
from e in emps,
    d in depts
  where e.deptno = d.deptno
  yield {d.deptno, e.name};
> val it =
>   [{deptno=10,name="Fred"},{deptno=20,name="Velma"},{deptno=30,name="Shaggy"},
>    {deptno=30,name="Scooby"}] : {deptno:int, name:string} list
from e in emps,
    d in depts
  where #deptno e = #deptno d
  yield {deptno = #deptno d, name = #name e};
> val it =
>   [{deptno=10,name="Fred"},{deptno=20,name="Velma"},{deptno=30,name="Shaggy"},
>    {deptno=30,name="Scooby"}] : {deptno:int, name:string} list

(*) WordCount
let
  fun split0 [] word words = word :: words
    | split0 (#" " :: s) word words = split0 s "" (word :: words)
    | split0 (c :: s) word words = split0 s (word ^ (String.str c)) words
  fun split s = List.rev (split0 (String.explode s) "" [])
in
  from line in lines,
    word in split line
  group word compute c = count
  order word
end;
> val it =
>   [{c=2,word="a"},{c=1,word="and"},{c=1,word="but"},{c=1,word="on"},
>    {c=1,word="sat"},{c=2,word="skunk"},{c=3,word="stump"},{c=2,word="stunk"},
>    {c=3,word="the"},{c=2,word="thunk"}] : {c:int, word:string} list
from p in wordCount ["a skunk sat on a stump",
    "and thunk the stump stunk",
    "but the stump thunk the skunk stunk"]
order p.word;
> val it =
>   [{count=2,word="a"},{count=1,word="and"},{count=1,word="but"},
>    {count=1,word="on"},{count=1,word="sat"},{count=2,word="skunk"},
>    {count=3,word="stump"},{count=2,word="stunk"},{count=3,word="the"},
>    {count=2,word="thunk"}] : {count:int, word:string} list

(*) Functions as views, functions as values
fun emps2 () =
   from e in emps
     yield {e.id,
       e.name,
       e.deptno,
       comp = fn revenue => case e.deptno of
           30 => e.id + revenue / 2
         | _ => e.id};
> val emps2 = fn
>   : unit -> {comp:int -> int, deptno:int, id:int, name:string} list
from e in emps2 ()
  yield {e.name, e.id, c = e.comp 1000};
> val it =
>   [{c=100,id=100,name="Fred"},{c=101,id=101,name="Velma"},
>    {c=602,id=102,name="Shaggy"},{c=603,id=103,name="Scooby"}]
>   : {c:int, id:int, name:string} list

(*) Chaining relational operators
from e in emps;
> val it =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list
from e in emps
  order e.deptno, e.id desc;
> val it =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=103,name="Scooby"},{deptno=30,id=102,name="Shaggy"}]
>   : {deptno:int, id:int, name:string} list
from e in emps
  order e.deptno, e.id desc
  yield {e.name, nameLength = String.size e.name, e.id, e.deptno};
> val it =
>   [{deptno=10,id=100,name="Fred",nameLength=4},
>    {deptno=20,id=101,name="Velma",nameLength=5},
>    {deptno=30,id=103,name="Scooby",nameLength=6},
>    {deptno=30,id=102,name="Shaggy",nameLength=6}]
>   : {deptno:int, id:int, name:string, nameLength:int} list
from e in emps
  order e.deptno, e.id desc
  yield {e.name, nameLength = String.size e.name, e.id, e.deptno}
  where nameLength > 4;
> val it =
>   [{deptno=20,id=101,name="Velma",nameLength=5},
>    {deptno=30,id=103,name="Scooby",nameLength=6},
>    {deptno=30,id=102,name="Shaggy",nameLength=6}]
>   : {deptno:int, id:int, name:string, nameLength:int} list
from e in emps
  order e.deptno, e.id desc
  yield {e.name, nameLength = String.size e.name, e.id, e.deptno}
  where nameLength > 4
  group deptno compute c = count, s = sum of nameLength;
> val it = [{c=1,deptno=20,s=5},{c=2,deptno=30,s=12}]
>   : {c:int, deptno:int, s:int} list
from e in emps
  order e.deptno, e.id desc
  yield {e.name, nameLength = String.size e.name, e.id, e.deptno}
  where nameLength > 4
  group deptno compute c = count, s = sum of nameLength
  where s > 10;
> val it = [{c=2,deptno=30,s=12}] : {c:int, deptno:int, s:int} list
from e in emps
  order e.deptno, e.id desc
  yield {e.name, nameLength = String.size e.name, e.id, e.deptno}
  where nameLength > 4
  group deptno compute c = count, s = sum of nameLength
  where s > 10
  yield c + s;
> val it = [14] : int list

(*) Integration with Apache Calcite - schemas
foodmart;
> val it =
>   {account=<relation>,agg_c_10_sales_fact_1997=<relation>,
>    agg_c_14_sales_fact_1997=<relation>,
>    agg_c_special_sales_fact_1997=<relation>,
>    agg_g_ms_pcat_sales_fact_1997=<relation>,
>    agg_l_03_sales_fact_1997=<relation>,agg_l_04_sales_fact_1997=<relation>,
>    agg_l_05_sales_fact_1997=<relation>,agg_lc_06_sales_fact_1997=<relation>,
>    agg_lc_100_sales_fact_1997=<relation>,agg_ll_01_sales_fact_1997=<relation>,
>    agg_pl_01_sales_fact_1997=<relation>,category=<relation>,
>    currency=<relation>,customer=<relation>,days=<relation>,
>    department=<relation>,employee=<relation>,employee_closure=<relation>,
>    expense_fact=<relation>,inventory_fact_1997=<relation>,
>    inventory_fact_1998=<relation>,position=<relation>,product=<relation>,
>    product_class=<relation>,promotion=<relation>,region=<relation>,
>    reserve_employee=<relation>,salary=<relation>,sales_fact_1997=<relation>,
>    sales_fact_1998=<relation>,sales_fact_dec_1998=<relation>,store=<relation>,
>    store_ragged=<relation>,time_by_day=<relation>,warehouse=<relation>,
>    warehouse_class=<relation>}
>   : {
>      account:
>              {account_description:string, account_id:int, account_parent:int,
>               account_rollup:string, account_type:string,
>               custom_members:string} list,
>      agg_c_10_sales_fact_1997:
>                               {customer_count:int, fact_count:int,
>                                month_of_year:int, quarter:string,
>                                store_cost:real, store_sales:real, the_year:int,
>                                unit_sales:real} list,
>      agg_c_14_sales_fact_1997:
>                               {customer_id:int, fact_count:int,
>                                month_of_year:int, product_id:int,
>                                promotion_id:int, quarter:string,
>                                store_cost:real, store_id:int, store_sales:real,
>                                the_year:int, unit_sales:real} list,
>      agg_c_special_sales_fact_1997:
>                                    {customer_id:int, fact_count:int,
>                                     product_id:int, promotion_id:int,
>                                     store_cost_sum:real, store_id:int,
>                                     store_sales_sum:real, time_month:int,
>                                     time_quarter:string, time_year:int,
>                                     unit_sales_sum:real} list,
>      agg_g_ms_pcat_sales_fact_1997:
>                                    {customer_count:int, fact_count:int,
>                                     gender:string, marital_status:string,
>                                     month_of_year:int, product_category:string,
>                                     product_department:string,
>                                     product_family:string, quarter:string,
>                                     store_cost:real, store_sales:real,
>                                     the_year:int, unit_sales:real} list,
>      agg_l_03_sales_fact_1997:
>                               {customer_id:int, fact_count:int,
>                                store_cost:real, store_sales:real, time_id:int,
>                                unit_sales:real} list,
>      agg_l_04_sales_fact_1997:
>                               {customer_count:int, fact_count:int,
>                                store_cost:real, store_sales:real, time_id:int,
>                                unit_sales:real} list,
>      agg_l_05_sales_fact_1997:
>                               {customer_id:int, fact_count:int, product_id:int,
>                                promotion_id:int, store_cost:real, store_id:int,
>                                store_sales:real, unit_sales:real} list,
>      agg_lc_06_sales_fact_1997:
>                                {city:string, country:string, fact_count:int,
>                                 state_province:string, store_cost:real,
>                                 store_sales:real, time_id:int, unit_sales:real} list,
>      agg_lc_100_sales_fact_1997:
>                                 {customer_id:int, fact_count:int,
>                                  product_id:int, quarter:string,
>                                  store_cost:real, store_sales:real,
>                                  the_year:int, unit_sales:real} list,
>      agg_ll_01_sales_fact_1997:
>                                {customer_id:int, fact_count:int,
>                                 product_id:int, store_cost:real,
>                                 store_sales:real, time_id:int, unit_sales:real} list,
>      agg_pl_01_sales_fact_1997:
>                                {customer_id:int, fact_count:int,
>                                 product_id:int, store_cost_sum:real,
>                                 store_sales_sum:real, time_id:int,
>                                 unit_sales_sum:real} list,
>      category:
>               {category_description:string, category_id:string,
>                category_parent:string, category_rollup:string} list,
>      currency:
>               {conversion_ratio:real, currency:string, currency_id:int,
>                date:string} list,
>      customer:
>               {account_num:int, address1:string, address2:string,
>                address3:string, address4:string, birthdate:string, city:string,
>                country:string, customer_id:int, customer_region_id:int,
>                date_accnt_opened:string, education:string, fname:string,
>                fullname:string, gender:string, houseowner:string, lname:string,
>                marital_status:string, member_card:string, mi:string,
>                num_cars_owned:int, num_children_at_home:int, occupation:string,
>                phone1:string, phone2:string, postal_code:string,
>                state_province:string, total_children:int, yearly_income:string} list,
>      days:{day:int, week_day:string} list,
>      department:{department_description:string, department_id:int} list,
>      employee:
>               {birth_date:string, department_id:int, education_level:string,
>                employee_id:int, end_date:string, first_name:string,
>                full_name:string, gender:string, hire_date:string,
>                last_name:string, management_role:string, marital_status:string,
>                position_id:int, position_title:string, salary:real,
>                store_id:int, supervisor_id:int} list,
>      employee_closure:{distance:int, employee_id:int, supervisor_id:int} list,
>      expense_fact:
>                   {account_id:int, amount:real, category_id:string,
>                    currency_id:int, exp_date:string, store_id:int, time_id:int} list,
>      inventory_fact_1997:
>                          {product_id:int, store_id:int, store_invoice:real,
>                           supply_time:int, time_id:int, units_ordered:int,
>                           units_shipped:int, warehouse_cost:real,
>                           warehouse_id:int, warehouse_sales:real} list,
>      inventory_fact_1998:
>                          {product_id:int, store_id:int, store_invoice:real,
>                           supply_time:int, time_id:int, units_ordered:int,
>                           units_shipped:int, warehouse_cost:real,
>                           warehouse_id:int, warehouse_sales:real} list,
>      position:
>               {management_role:string, max_scale:real, min_scale:real,
>                pay_type:string, position_id:int, position_title:string} list,
>      product:
>              {brand_name:string, cases_per_pallet:int, gross_weight:real,
>               low_fat:bool, net_weight:real, product_class_id:int,
>               product_id:int, product_name:string, recyclable_package:bool,
>               shelf_depth:real, shelf_height:real, shelf_width:real, sku:int,
>               srp:real, units_per_case:int} list,
>      product_class:
>                    {product_category:string, product_class_id:int,
>                     product_department:string, product_family:string,
>                     product_subcategory:string} list,
>      promotion:
>                {cost:real, end_date:string, media_type:string,
>                 promotion_district_id:int, promotion_id:int,
>                 promotion_name:string, start_date:string} list,
>      region:
>             {region_id:int, sales_city:string, sales_country:string,
>              sales_district:string, sales_district_id:int, sales_region:string,
>              sales_state_province:string} list,
>      reserve_employee:
>                       {birth_date:string, department_id:int,
>                        education_level:string, employee_id:int,
>                        end_date:string, first_name:string, full_name:string,
>                        gender:string, hire_date:string, last_name:string,
>                        marital_status:string, position_id:int,
>                        position_title:string, salary:real, store_id:int,
>                        supervisor_id:int} list,
>      salary:
>             {currency_id:int, department_id:int, employee_id:int,
>              overtime_paid:real, pay_date:string, salary_paid:real,
>              vacation_accrued:real, vacation_used:real} list,
>      sales_fact_1997:
>                      {customer_id:int, product_id:int, promotion_id:int,
>                       store_cost:real, store_id:int, store_sales:real,
>                       time_id:int, unit_sales:real} list,
>      sales_fact_1998:
>                      {customer_id:int, product_id:int, promotion_id:int,
>                       store_cost:real, store_id:int, store_sales:real,
>                       time_id:int, unit_sales:real} list,
>      sales_fact_dec_1998:
>                          {customer_id:int, product_id:int, promotion_id:int,
>                           store_cost:real, store_id:int, store_sales:real,
>                           time_id:int, unit_sales:real} list,
>      store:
>            {coffee_bar:bool, first_opened_date:string, florist:bool,
>             frozen_sqft:int, grocery_sqft:int, last_remodel_date:string,
>             meat_sqft:int, prepared_food:bool, region_id:int, salad_bar:bool,
>             store_city:string, store_country:string, store_fax:string,
>             store_id:int, store_manager:string, store_name:string,
>             store_number:int, store_phone:string, store_postal_code:string,
>             store_sqft:int, store_state:string, store_street_address:string,
>             store_type:string, video_store:bool} list,
>      store_ragged:
>                   {coffee_bar:bool, first_opened_date:string, florist:bool,
>                    frozen_sqft:int, grocery_sqft:int, last_remodel_date:string,
>                    meat_sqft:int, prepared_food:bool, region_id:int,
>                    salad_bar:bool, store_city:string, store_country:string,
>                    store_fax:string, store_id:int, store_manager:string,
>                    store_name:string, store_number:int, store_phone:string,
>                    store_postal_code:string, store_sqft:int,
>                    store_state:string, store_street_address:string,
>                    store_type:string, video_store:bool} list,
>      time_by_day:
>                  {day_of_month:int, fiscal_period:string, month_of_year:int,
>                   quarter:string, the_date:string, the_day:string,
>                   the_month:string, the_year:int, time_id:int,
>                   week_of_year:int} list,
>      warehouse:
>                {stores_id:int, wa_address1:string, wa_address2:string,
>                 wa_address3:string, wa_address4:string, warehouse_city:string,
>                 warehouse_class_id:int, warehouse_country:string,
>                 warehouse_fax:string, warehouse_id:int, warehouse_name:string,
>                 warehouse_owner_name:string, warehouse_phone:string,
>                 warehouse_postal_code:string, warehouse_state_province:string} list,
>      warehouse_class:{description:string, warehouse_class_id:int} list}
scott;
> val it = {bonus=<relation>,dept=<relation>,emp=<relation>,salgrade=<relation>}
>   : {bonus:{comm:real, ename:string, job:string, sal:real} list,
>      dept:{deptno:int, dname:string, loc:string} list,
>      emp:
>          {comm:real, deptno:int, empno:int, ename:string, hiredate:string,
>           job:string, mgr:int, sal:real} list,
>      salgrade:{grade:int, hisal:real, losal:real} list}
scott.dept;
> val it = <relation> : {deptno:int, dname:string, loc:string} list
from d in scott.dept
  where notExists (from e in scott.emp
    where e.deptno = d.deptno
    andalso e.job = "CLERK");
> val it = [{deptno=40,dname="OPERATIONS",loc="BOSTON"}]
>   : {deptno:int, dname:string, loc:string} list

(*) Integration with Apache Calcite - relational algebra
Sys.set ("hybrid", true);
> val it = () : unit
from d in scott.dept
  where notExists (from e in scott.emp
    where e.deptno = d.deptno
    andalso e.job = "CLERK");
> val it = [{deptno=40,dname="OPERATIONS",loc="BOSTON"}]
>   : {deptno:int, dname:string, loc:string} list
Sys.plan();
> val it =
>   "calcite(plan LogicalProject(deptno=[$0], dname=[$1], loc=[$2])
>   LogicalFilter(condition=[IS NULL($4)])
>     LogicalJoin(condition=[=($0, $3)], joinType=[left])
>       LogicalProject(deptno=[$0], dname=[$1], loc=[$2])
>         JdbcTableScan(table=[[scott, DEPT]])
>       LogicalProject(deptno=[$0], $f1=[true])
>         LogicalAggregate(group=[{0}])
>           LogicalProject(deptno=[$1])
>             LogicalFilter(condition=[AND(=($5, 'CLERK'), IS NOT NULL($1))])
>               LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])
>                 JdbcTableScan(table=[[scott, EMP]])
> )"
>   : string

(*) Functional programming <=> relational programming
fun squareList [] = []
  | squareList (x :: xs) = x * x :: squareList xs;
> val squareList = fn : int list -> int list
squareList [1, 2, 3];
> val it = [1,4,9] : int list
fun squareList xs = List.map (fn x => x * 2) xs;
> val squareList = fn : int list -> int list
squareList [1, 2, 3];
> val it = [2,4,6] : int list
fun squareList xs =
  from x in xs
    yield x * x;
> val squareList = fn : int list -> int list
squareList [1, 2, 3];
> val it = [1,4,9] : int list

(*) wordCount again
fun mapReduce mapper reducer list =
  from e in list,
      (k, v) in mapper e
    group k compute c = (fn vs => reducer (k, vs)) of v;
> val mapReduce = fn
>   : ('a -> ('b * 'c) list) ->
>      ('b * 'c list -> 'd) -> 'a list -> {c:'d, k:'b} list
fun wc_mapper line =
  List.map (fn w => (w, 1)) (split line);
> val wc_mapper = fn : string -> (string * int) list
fun wc_reducer (key, values) =
  List.foldl (fn (x, y) => x + y) 0 values;
> val wc_reducer = fn : 'a * int list -> int
val wordCount = mapReduce wc_mapper wc_reducer;
> val wordCount = fn : string list -> {c:int, k:string} list
from p in wordCount lines order p.k;
> val it =
>   [{c=2,k="a"},{c=1,k="and"},{c=1,k="but"},{c=1,k="on"},{c=1,k="sat"},
>    {c=2,k="skunk"},{c=3,k="stump"},{c=2,k="stunk"},{c=3,k="the"},
>    {c=2,k="thunk"}] : {c:int, k:string} list
from line in lines,
   word in split line
 group word compute c = count
 order word;
> val it =
>   [{c=2,word="a"},{c=1,word="and"},{c=1,word="but"},{c=1,word="on"},
>    {c=1,word="sat"},{c=2,word="skunk"},{c=3,word="stump"},{c=2,word="stunk"},
>    {c=3,word="the"},{c=2,word="thunk"}] : {c:int, word:string} list

(*) === Coda ========================================================
from message in ["the end"];
> val it = ["the end"] : string list

(*) End blog.smli
