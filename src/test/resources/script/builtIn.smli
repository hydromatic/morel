(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)
Sys.set ("lineWidth", 78);
> val it = () : unit
Sys.set ("printLength", 999);
> val it = () : unit
Sys.set ("stringDepth", ~1);
> val it = () : unit

(* Until we have a real "print" function, we use "ignore" to
   suppress the output of expressions. *)
fun print x = ignore x;
> val print = fn : 'a -> unit

(* Structures -------------------------------------------------- *)
General;
> val it = {ignore=fn,`op o`=fn}
>   : {ignore:'a -> unit, `op o`:('b -> 'c) * ('d -> 'b) -> 'd -> 'c}
Char;
> val it =
>   {chr=fn,compare=fn,contains=fn,fromCString=fn,fromString=fn,isAlpha=fn,
>    isAlphaNum=fn,isAscii=fn,isCntrl=fn,isDigit=fn,isGraph=fn,isHexDigit=fn,
>    isLower=fn,isPrint=fn,isPunct=fn,isSpace=fn,isUpper=fn,maxChar=#"\255",
>    maxOrd=255,minChar=#"\^@",notContains=fn,`op <`=fn,`op <=`=fn,`op >`=fn,
>    `op >=`=fn,ord=fn,pred=fn,succ=fn,toCString=fn,toLower=fn,toString=fn,
>    toUpper=fn}
>   : {chr:int -> char, compare:char * char -> order,
>      contains:string -> char -> bool, fromCString:string -> char option,
>      fromString:string -> char option, isAlpha:char -> bool,
>      isAlphaNum:char -> bool, isAscii:char -> bool, isCntrl:char -> bool,
>      isDigit:char -> bool, isGraph:char -> bool, isHexDigit:char -> bool,
>      isLower:char -> bool, isPrint:char -> bool, isPunct:char -> bool,
>      isSpace:char -> bool, isUpper:char -> bool, maxChar:char, maxOrd:int,
>      minChar:char, notContains:string -> char -> bool,
>      `op <`:char * char -> bool, `op <=`:char * char -> bool,
>      `op >`:char * char -> bool, `op >=`:char * char -> bool, ord:char -> int,
>      pred:char -> char, succ:char -> char, toCString:char -> string,
>      toLower:char -> char, toString:char -> string, toUpper:char -> char}
Int;
> val it =
>   {abs=fn,compare=fn,div=fn,fromInt=fn,fromLarge=fn,fromString=fn,max=fn,
>    maxInt=SOME 2147483647,min=fn,minInt=SOME 2147483647,mod=fn,
>    precision=SOME 32,quot=fn,rem=fn,sameSign=fn,sign=fn,toInt=fn,toLarge=fn,
>    toString=fn}
>   : {abs:int -> int, compare:int * int -> order, div:int * int -> int,
>      fromInt:int -> int, fromLarge:int -> int, fromString:string -> int option,
>      max:int * int -> int, maxInt:int option, min:int * int -> int,
>      minInt:int option, mod:int * int -> int, precision:int option,
>      quot:int * int -> int, rem:int * int -> int, sameSign:int * int -> bool,
>      sign:int -> int, toInt:int -> int, toLarge:int -> int,
>      toString:int -> string}
Interact;
> val it = {use=fn,useSilently=fn}
>   : {use:string -> unit, useSilently:string -> unit}
List;
> val it =
>   {all=fn,app=fn,at=fn,collate=fn,concat=fn,drop=fn,except=fn,exists=fn,
>    filter=fn,find=fn,foldl=fn,foldr=fn,getItem=fn,hd=fn,intersect=fn,last=fn,
>    length=fn,map=fn,mapPartial=fn,mapi=fn,nil=[],nth=fn,null=fn,`op @`=fn,
>    partition=fn,rev=fn,revAppend=fn,tabulate=fn,take=fn,tl=fn}
>   : {all:('a -> bool) -> 'a list -> bool, app:('b -> unit) -> 'b list -> unit,
>      at:'c list * 'c list -> 'c list,
>      collate:('d * 'd -> order) -> 'd list * 'd list -> order,
>      concat:'e list list -> 'e list, drop:'f list * int -> 'f list,
>      except:'g list list -> 'g list, exists:('h -> bool) -> 'h list -> bool,
>      filter:('i -> bool) -> 'i list -> 'i list,
>      find:('j -> bool) -> 'j list -> 'j option,
>      foldl:('k * 'l -> 'l) -> 'l -> 'k list -> 'l,
>      foldr:('m * 'n -> 'n) -> 'n -> 'm list -> 'n,
>      getItem:'o list -> ('o * 'o list) option, hd:'p list -> 'p,
>      intersect:'q list list -> 'q list, last:'r list -> 'r,
>      length:'s list -> int, map:('t -> 'u) -> 't list -> 'u list,
>      mapPartial:('v -> 'w option) -> 'v list -> 'w list,
>      mapi:(int * 'x -> 'y) -> 'x list -> 'y list, nil:'z list,
>      nth:'ba list * int -> 'ba, null:'bb list -> bool,
>      `op @`:'bc list * 'bc list -> 'bc list,
>      partition:('bd -> bool) -> 'bd list -> 'bd list * 'bd list,
>      rev:'be list -> 'be list, revAppend:'bf list * 'bf list -> 'bf list,
>      tabulate:int * (int -> 'bg) -> 'bg list, take:'bh list * int -> 'bh list,
>      tl:'bi list -> 'bi list}
ListPair;
> val it =
>   {all=fn,allEq=fn,app=fn,appEq=fn,exists=fn,foldl=fn,foldlEq=fn,foldr=fn,
>    foldrEq=fn,map=fn,mapEq=fn,unzip=fn,zip=fn,zipEq=fn}
>   : {all:('a * 'b -> bool) -> 'a list * 'b list -> bool,
>      allEq:('c * 'd -> bool) -> 'c list * 'd list -> bool,
>      app:('e * 'f -> unit) -> 'e list * 'f list -> unit,
>      appEq:('g * 'h -> unit) -> 'g list * 'h list -> unit,
>      exists:('i * 'j -> bool) -> 'i list * 'j list -> bool,
>      foldl:('k * 'l * 'm -> 'm) -> 'm -> 'k list * 'l list -> 'm,
>      foldlEq:('n * 'o * 'p -> 'p) -> 'p -> 'n list * 'o list -> 'p,
>      foldr:('q * 'r * 's -> 's) -> 's -> 'q list * 'r list -> 's,
>      foldrEq:('t * 'u * 'v -> 'v) -> 'v -> 't list * 'u list -> 'v,
>      map:('w * 'x -> 'y) -> 'w list * 'x list -> 'y list,
>      mapEq:('z * 'ba -> 'bb) -> 'z list * 'ba list -> 'bb list,
>      unzip:('bc * 'bd) list -> 'bc list * 'bd list,
>      zip:'be list * 'bf list -> ('be * 'bf) list,
>      zipEq:'bg list * 'bh list -> ('bg * 'bh) list}
Math;
> val it =
>   {acos=fn,asin=fn,atan=fn,atan2=fn,cos=fn,cosh=fn,e=2.7182817,exp=fn,ln=fn,
>    log10=fn,pi=3.1415927,pow=fn,sin=fn,sinh=fn,sqrt=fn,tan=fn,tanh=fn}
>   : {acos:real -> real, asin:real -> real, atan:real -> real,
>      atan2:real * real -> real, cos:real -> real, cosh:real -> real, e:real,
>      exp:real -> real, ln:real -> real, log10:real -> real, pi:real,
>      pow:real * real -> real, sin:real -> real, sinh:real -> real,
>      sqrt:real -> real, tan:real -> real, tanh:real -> real}
Option;
> val it =
>   {app=fn,compose=fn,composePartial=fn,filter=fn,getOpt=fn,isSome=fn,join=fn,
>    map=fn,mapPartial=fn,valOf=fn}
>   : {app:('a option -> unit) -> 'a option -> unit,
>      compose:('b -> 'c) * ('d -> 'b option) -> 'd -> 'c option,
>      composePartial:('e -> 'f option) * ('g -> 'e option) -> 'g -> 'f option,
>      filter:('h -> bool) -> 'h -> 'h option, getOpt:'i option * 'i -> 'i,
>      isSome:'j option -> bool, join:'k option option -> 'k option,
>      map:('l -> 'm) -> 'l option -> 'm option,
>      mapPartial:('n -> 'o option) -> 'n option -> 'o option,
>      valOf:'p option -> 'p}
String;
> val it =
>   {collate=fn,compare=fn,concat=fn,concatWith=fn,explode=fn,extract=fn,
>    fields=fn,implode=fn,isPrefix=fn,isSubstring=fn,isSuffix=fn,map=fn,
>    maxSize=2147483647,`op <`=fn,`op <=`=fn,`op >`=fn,`op >=`=fn,`op ^`=fn,
>    size=fn,str=fn,sub=fn,substring=fn,tokens=fn,translate=fn}
>   : {collate:(char * char -> order) -> string * string -> order,
>      compare:string * string -> order, concat:string list -> string,
>      concatWith:string -> string list -> string, explode:string -> char list,
>      extract:string * int * int option -> string,
>      fields:(char -> bool) -> string -> string list,
>      implode:char list -> string, isPrefix:string -> string -> bool,
>      isSubstring:string -> string -> bool, isSuffix:string -> string -> bool,
>      map:(char -> char) -> string -> string, maxSize:int,
>      `op <`:string * string -> bool, `op <=`:string * string -> bool,
>      `op >`:string * string -> bool, `op >=`:string * string -> bool,
>      `op ^`:string * string -> string, size:string -> int, str:char -> string,
>      sub:string * int -> char, substring:string * int * int -> string,
>      tokens:(char -> bool) -> string -> string list,
>      translate:(char -> string) -> string -> string}
Real;
> val it =
>   {abs=fn,ceil=fn,checkFloat=fn,compare=fn,copySign=fn,floor=fn,fromInt=fn,
>    fromManExp=fn,fromString=fn,isFinite=fn,isNan=fn,isNormal=fn,max=fn,
>    maxFinite=3.4028235E38,min=fn,minNormalPos=1.1754944E~38,minPos=1.4E~45,
>    negInf=~inf,posInf=inf,precision=24,radix=2,realCeil=fn,realFloor=fn,
>    realMod=fn,realRound=fn,realTrunc=fn,rem=fn,round=fn,sameSign=fn,sign=fn,
>    signBit=fn,split=fn,toManExp=fn,toString=fn,trunc=fn,unordered=fn}
>   : {abs:real -> real, ceil:real -> int, checkFloat:real -> real,
>      compare:real * real -> order, copySign:real * real -> real,
>      floor:real -> int, fromInt:int -> real,
>      fromManExp:{exp:int, man:real} -> real, fromString:string -> real option,
>      isFinite:real -> bool, isNan:real -> bool, isNormal:real -> bool,
>      max:real * real -> real, maxFinite:real, min:real * real -> real,
>      minNormalPos:real, minPos:real, negInf:real, posInf:real, precision:int,
>      radix:int, realCeil:real -> real, realFloor:real -> real,
>      realMod:real -> real, realRound:real -> real, realTrunc:real -> real,
>      rem:real * real -> real, round:real -> int, sameSign:real * real -> bool,
>      sign:real -> int, signBit:real -> bool,
>      split:real -> {frac:real, whole:real},
>      toManExp:real -> {exp:int, man:real}, toString:real -> string,
>      trunc:real -> int, unordered:real * real -> bool}
Relational;
> val it =
>   {compare=fn,count=fn,empty=fn,iterate=fn,max=fn,min=fn,nonEmpty=fn,only=fn,
>    sum=fn}
>   : {compare:'a * 'a -> order, count:'b bag -> int, empty:'c bag -> bool,
>      iterate:'d bag -> ('d bag * 'd bag -> 'd bag) -> 'd bag, max:'e bag -> 'e,
>      min:'f bag -> 'f, nonEmpty:'g bag -> bool, only:'h bag -> 'h,
>      sum:'i bag -> 'i}
Sys;
> val it =
>   {clearEnv=fn,env=fn,file={},plan=fn,set=fn,show=fn,showAll=fn,unset=fn}
>   : {clearEnv:unit -> unit, env:unit -> (string * string) list, file:{...},
>      plan:unit -> string, set:string * 'a -> unit,
>      show:string -> string option,
>      showAll:unit -> (string * string option) list, unset:string -> unit}

(* Operators --------------------------------------------------- *)
2 + 3;
> val it = 5 : int
2 + 3 * 4;
> val it = 14 : int
Sys.plan ();
> val it =
>   "apply2(fnValue +, constant(2), apply2(fnValue *, constant(3), constant(4)))"
>   : string
14 div 3;
> val it = 4 : int
14 div ~3;
> val it = ~5 : int

from (i, j) in [(14, 3), (~14, 3), (14, ~3), (~14, ~3)]
 where (i div j) <> Int.`div` (i, j)
 orelse (i mod j) <> Int.`mod` (i, j);
> val it = [] : {i:int, j:int} list

fn x => x + 1;
> val it = fn : int -> int
Sys.plan ();
> val it = "match(x, apply2(fnValue +, get(name x), constant(1)))" : string

val nan = Real.posInf / Real.posInf;
> val nan = nan : real

(* Datatypes --------------------------------------------------- *)

(*
 * The "option" datatype, declared as follows:
 *   datatype 'a option = NONE | SOME
 *)
SOME 1;
> val it = SOME 1 : int option
NONE;
> val it = NONE : 'a option
NONE = NONE;
> val it = true : bool
NONE = SOME 1;
> val it = false : bool
SOME "a" = NONE;
> val it = false : bool
SOME (SOME true);
> val it = SOME (SOME true) : bool option option
SOME (SOME [1,2,3]);
> val it = SOME (SOME [1,2,3]) : int list option option
SOME (SOME {a=1, b=true});
> val it = SOME (SOME {a=1,b=true}) : {a:int, b:bool} option option

(*
 * The "descending" datatype, declared as follows:
 *   datatype 'a descending = DESC of 'a;
 *)
DESC;
> val it = fn : 'a -> 'a descending
DESC 1;
> val it = DESC 1 : int descending
DESC (DESC "a");
> val it = DESC (DESC "a") : string descending descending

(* Top-level environment --------------------------------------- *)
(* A few functions and operators belong to signatures but can be
   used unqualified. For example, "hd" is shorthand for "List.hd".
   The following are all of the top-level functions and operators
   defined by Standard ML. *)

(* "val ! : 'a ref -> 'a" maps to "General.!" *)
(*) TODO !;
(* "val := : 'a ref * 'a -> unit" maps to "General.:=" *)
(*) TODO :=;
(* "val @ : ('a list * 'a list) -> 'a list" maps to "List.@" *)
(*) TODO @;
(* "val ^ : string * string -> string" maps to "String.^" *)
(*) TODO ^;
(* "val app : ('a -> unit) -> 'a list -> unit" maps to "List.app" *)
app;
> val it = fn : ('a -> unit) -> 'a list -> unit
(* "val before : 'a * unit -> 'a" maps to "General.before" *)
(*) TODO before;
(* "val ceil : real -> int" maps to "Real.ceil" *)
ceil;
> val it = fn : real -> int
(* "val chr : int -> char" maps to "Char.chr" *)
chr;
> val it = fn : int -> char
(* "val compare : 'a * 'a -> order" maps to "String.compare" *)
String.compare;
> val it = fn : string * string -> order
String.compare ("abc", "xyz");
> val it = LESS : order
String.compare ("abc", "");
> val it = GREATER : order
(* "val concat : string list -> string" maps to "String.concat" *)
concat;
> val it = fn : string list -> string
(* "val exnMessage : exn -> string" maps to "General.exnMessage" *)
(*) TODO exnMessage;
(* "val exnName : exn -> string" maps to "General.exnName" *)
(*) TODO exnName;
(* "val explode : string -> char list" maps to "String.explode" *)
explode;
> val it = fn : string -> char list
(* "val floor : real -> int" maps to "Real.floor" *)
floor;
> val it = fn : real -> int
(* "val foldl : ('a*'b->'b)-> 'b -> 'a list -> 'b" maps to "List.foldl" *)
foldl;
> val it = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
(* "val foldr : ('a*'b->'b)-> 'b -> 'a list -> 'b" maps to "List.foldr" *)
foldr;
> val it = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
(* "val getOpt : ('a option * 'a) -> 'a" maps to "Option.getOpt" *)
getOpt;
> val it = fn : 'a option * 'a -> 'a
(* "val hd : 'a list -> 'a" maps to "List.hd" *)
hd;
> val it = fn : 'a list -> 'a
(* "val ignore : 'a -> unit" maps to "General.ignore" *)
ignore;
> val it = fn : 'a -> unit
(* "val implode : char list -> string" maps to "String.implode" *)
implode;
> val it = fn : char list -> string
(* "val isSome : 'a option -> bool" maps to "Option.isSome" *)
isSome;
> val it = fn : 'a option -> bool
(* "val length : 'a list -> int" maps to "List.length" *)
length;
> val it = fn : 'a list -> int
(* "val map : ('a -> 'b) -> 'a list -> 'b list" maps to "List.map" *)
map;
> val it = fn : ('a -> 'b) -> 'a list -> 'b list
(* "val not : bool -> bool" maps to "Bool.not" *)
not;
> val it = fn : bool -> bool
(* "val null : 'a list -> bool" maps to "List.null" *)
null;
> val it = fn : 'a list -> bool
(* "val o : ('a->'b) * ('c->'a) -> 'c->'b" maps to "General.o" *)
(*) TODO o;
(* "val ord : char -> int" maps to "Char.ord" *)
(*) TODO ord;
(* "val print : string -> unit" maps to "TextIO.print" *)
(*) TODO print;
(* "val real : int -> real" maps to "Real.fromInt" *)
real;
> val it = fn : int -> real
(* "val ref : 'a -> 'a ref" maps to "primitive" *)
(*) TODO ref;
(* "val rev : 'a list -> 'a list" maps to "List.rev" *)
rev;
> val it = fn : 'a list -> 'a list
(* "val round : real -> int" maps to "Real.round" *)
round;
> val it = fn : real -> int
(* "val size : string -> int" maps to "String.size" *)
size;
> val it = fn : string -> int
(* "val str : char -> string" maps to "String.str" *)
str;
> val it = fn : char -> string
(* "val substring : string * int * int -> string" maps to "String.substring" *)
substring;
> val it = fn : string * int * int -> string
(* "val tl : 'a list -> 'a list" maps to "List.tl" *)
tl;
> val it = fn : 'a list -> 'a list
(* "val trunc : real -> int" maps to "Real.trunc" *)
trunc;
> val it = fn : real -> int
(* "val use : string -> unit" maps to "implementation dependent" *)
use;
> val it = fn : string -> unit
(* "val valOf : 'a option -> 'a" maps to "Option.valOf" *)
valOf;
> val it = fn : 'a option -> 'a
(* "val vector : 'a list -> 'a vector" maps to "Vector.fromList" *)
vector;
> val it = fn : 'a list -> 'a vector

(* Bag --------------------------------------------------------- *)

(*) val nil : 'a bag
(* TODO
Bag.nil;
> val it = [] : 'a bag
Sys.plan ();
> val it = "constant([])" : string
*)

(*) val null : 'a bag -> bool
Bag.null;
> val it = fn : 'a bag -> bool
Bag.null (bag []);
> val it = true : bool
Bag.null (bag [1]);
> val it = false : bool
Sys.plan ();
> val it =
>   "apply(fnValue Bag.null, argCode apply(fnValue Bag.fromList, argCode tuple(constant(1))))"
>   : string

(*) val length : 'a bag -> int
Bag.length;
> val it = fn : 'a bag -> int
Bag.length (bag []);
> val it = 0 : int
Bag.length (bag [1,2]);
> val it = 2 : int
Sys.plan ();
> val it =
>   "apply(fnValue Bag.length, argCode apply(fnValue Bag.fromList, argCode tuple(constant(1), constant(2))))"
>   : string

(*) val fromList : 'a list -> 'a bag
Bag.fromList;
> val it = fn : 'a list -> 'a bag
Bag.fromList [1,2,3];
> val it = [1,2,3] : int bag

(*) val toList : 'a bag -> 'a list
Bag.toList;
> val it = fn : 'a bag -> 'a list
Bag.toList (bag [1,2,3]);
> val it = [1,2,3] : int list
Bag.toList Bag.nil;
> val it = [] : 'a list

(*) val @ : 'a bag * 'a bag -> 'a bag
Bag.at;
> val it = fn : 'a bag * 'a bag -> 'a bag
Bag.at (bag [1], bag [2, 3]);
> val it = [1,2,3] : int bag
Bag.at (bag [1], bag []);
> val it = [1] : int bag
Bag.at (bag [], bag [2]);
> val it = [2] : int bag
Bag.at (bag [], bag []);
> val it = [] : 'a bag
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.at, apply(fnValue Bag.fromList, argCode tuple), apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val hd : 'a bag -> 'a
Bag.hd;
> val it = fn : 'a bag -> 'a
Bag.hd (bag [1,2,3]);
> val it = 1 : int
Bag.hd (bag []);
> uncaught exception Empty
>   raised at: stdIn:1.1-1.15
Sys.plan ();
> val it =
>   "apply(fnValue List.hd, argCode apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val tl : 'a bag -> 'a bag
Bag.tl;
> val it = fn : 'a bag -> 'a bag
Bag.tl (bag [1,2,3]);
> val it = [2,3] : int bag
Bag.tl (bag []);
> uncaught exception Empty
>   raised at: stdIn:1.1-1.15
Sys.plan ();
> val it =
>   "apply(fnValue List.tl, argCode apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val getItem : 'a bag -> ('a * 'a bag) option
Bag.getItem;
> val it = fn : 'a bag -> ('a * 'a bag) option
Bag.getItem (bag [1,2,3]);
> val it = SOME (1,[2,3]) : (int * int bag) option
Bag.getItem (bag [1]);
> val it = SOME (1,[]) : (int * int bag) option
Sys.plan ();
> val it =
>   "apply(fnValue Bag.getItem, argCode apply(fnValue Bag.fromList, argCode tuple(constant(1))))"
>   : string

(*) val take : 'a bag * int -> 'a bag
Bag.`take`;
> val it = fn : 'a bag * int -> 'a bag
Bag.`take` (bag [1,2,3], 0);
> val it = [] : int bag
Bag.`take` (bag [1,2,3], 1);
> val it = [1] : int bag
Bag.`take` (bag [1,2,3], 3);
> val it = [1,2,3] : int bag
Bag.`take` (bag [1,2,3], 4);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.28
Bag.`take` (bag [1,2,3], ~1);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.29
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.take, apply(fnValue Bag.fromList, argCode tuple(constant(1), constant(2), constant(3))), constant(-1))"
>   : string

(*) val drop : 'a bag * int -> 'a bag
Bag.drop;
> val it = fn : 'a bag * int -> 'a bag
Bag.drop (bag [1,2,3], 0);
> val it = [1,2,3] : int bag
Bag.drop (bag [1,2,3], 1);
> val it = [2,3] : int bag
Bag.drop (bag [1,2,3], 3);
> val it = [] : int bag
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.drop, apply(fnValue Bag.fromList, argCode tuple(constant(1), constant(2), constant(3))), constant(3))"
>   : string

(*) val concat : 'a bag list -> 'a bag
Bag.concat;
> val it = fn : 'a bag list -> 'a bag
Bag.concat [bag [1], bag [2,3], bag [4,5,6]];
> val it = [1,2,3,4,5,6] : int bag
Bag.concat [bag [1], bag [], bag [4,5,6]];
> val it = [1,4,5,6] : int bag
Bag.concat [bag [1], Bag.nil, bag [4,5,6]];
> val it = [1,4,5,6] : int bag
Bag.concat [bag [], bag [], bag []];
> val it = [] : 'a bag
Bag.concat [];
> val it = [] : 'a bag
Sys.plan ();
> val it = "apply(fnValue Bag.concat, argCode tuple)" : string

(*) val app : ('a -> unit) -> 'a bag -> unit
Bag.app;
> val it = fn : ('a -> unit) -> 'a bag -> unit
Bag.app (fn x => ignore (x + 2)) (bag [2,3,4]);
> val it = () : unit
Bag.app (fn x => ignore (x + 2)) (bag []);
> val it = () : unit
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.app, match(x, apply(fnValue General.ignore, argCode apply2(fnValue +, get(name x), constant(2)))), apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val map : ('a -> 'b) -> 'a bag -> 'b bag
Bag.map;
> val it = fn : ('a -> 'b) -> 'a bag -> 'b bag
Bag.map (fn x => x + 1) (bag [1,2,3]);
> val it = [2,3,4] : int bag
Bag.map (fn x => x + 1) (bag []);
> val it = [] : int bag
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.map, match(x, apply2(fnValue +, get(name x), constant(1))), apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val mapPartial : ('a -> 'b option) -> 'a bag -> 'b bag
Bag.mapPartial;
> val it = fn : ('a -> 'b option) -> 'a bag -> 'b bag
Bag.mapPartial (fn x => if x mod 2 = 0 then NONE else SOME (x + 1)) (bag [1,2,3,5,8]);
> val it = [2,4,6] : int bag
Bag.mapPartial (fn x => if x mod 2 = 0 then NONE else SOME (x + 1)) (bag []);
> val it = [] : int bag
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.mapPartial, match(x, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply2(fnValue +, get(name x), constant(1)))), argCode apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0)))), apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val find : ('a -> bool) -> 'a bag -> 'a option
Bag.find;
> val it = fn : ('a -> bool) -> 'a bag -> 'a option
Bag.find (fn x => x mod 7 = 0) (bag [2,3,5,8,13,21,34]);
> val it = SOME 21 : int option
Bag.find (fn x => x mod 11 = 0) (bag [2,3,5,8,13,21,34]);
> val it = NONE : int option
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.find, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(11)), constant(0))), apply(fnValue Bag.fromList, argCode tuple(constant(2), constant(3), constant(5), constant(8), constant(13), constant(21), constant(34))))"
>   : string

(*) val filter : ('a -> bool) -> 'a bag -> 'a bag
Bag.filter;
> val it = fn : ('a -> bool) -> 'a bag -> 'a bag
Bag.filter (fn x => x mod 2 = 0) (bag [0,1,2,3,4,5]);
> val it = [0,2,4] : int bag
Bag.filter (fn x => x mod 2 = 0) (bag [1,3]);
> val it = [] : int bag
Bag.filter (fn x => x mod 2 = 0) (bag []);
> val it = [] : int bag
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.filter, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val partition : ('a -> bool) -> 'a bag -> 'a bag * 'a bag
Bag.partition;
> val it = fn : ('a -> bool) -> 'a bag -> 'a bag * 'a bag
Bag.partition (fn x => x mod 2 = 0) (bag [0,1,2,3,4,5]);
> val it = ([0,2,4],[1,3,5]) : int bag * int bag
Bag.partition (fn x => x mod 2 = 0) (bag [1]);
> val it = ([],[1]) : int bag * int bag
Bag.partition (fn x => x mod 2 = 0) (bag []);
> val it = ([],[]) : int bag * int bag
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.partition, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val fold : ('a * 'b -> 'b) -> 'b -> 'a bag -> 'b
Bag.fold;
> val it = fn : ('a * 'b -> 'b) -> 'b -> 'a bag -> 'b
Bag.fold (fn (a, b) => a + b) 0 (bag [1,2,3]);
> val it = 6 : int
Bag.fold (fn (a, b) => a + b) 0 (bag []);
> val it = 0 : int
Bag.fold (fn (a, b) => b) 0 (bag [1,2,3]);
> val it = 0 : int
Bag.fold (fn (a, b) => a - b) 0 (bag [1,2,3,4]);
> val it = 2 : int
Sys.plan ();
> val it =
>   "apply3(fnValue Bag.fold, match(v, apply(fnCode match((a, b), apply2(fnValue -, get(name a), get(name b))), argCode get(name v))), constant(0), apply(fnValue Bag.fromList, argCode tuple(constant(1), constant(2), constant(3), constant(4))))"
>   : string

(*) val exists : ('a -> bool) -> 'a bag -> bool
Bag.`exists`;
> val it = fn : ('a -> bool) -> 'a bag -> bool
Bag.`exists` (fn x => x mod 2 = 0) (bag [1,3,5]);
> val it = false : bool
Bag.`exists` (fn x => x mod 2 = 0) (bag [2,4,6]);
> val it = true : bool
Bag.`exists` (fn x => x mod 2 = 0) (bag [1,2,3]);
> val it = true : bool
Bag.`exists` (fn x => x mod 2 = 0) (bag []);
> val it = false : bool
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.exists, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val all : ('a -> bool) -> 'a bag -> bool
Bag.all;
> val it = fn : ('a -> bool) -> 'a bag -> bool
Bag.all (fn x => x mod 2 = 0) (bag [1,3,5]);
> val it = false : bool
Bag.all (fn x => x mod 2 = 0) (bag [2,4,6]);
> val it = true : bool
Bag.all (fn x => x mod 2 = 0) (bag [1,2,3]);
> val it = false : bool
Bag.all (fn x => x mod 2 = 0) (bag []);
> val it = true : bool
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.all, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), apply(fnValue Bag.fromList, argCode tuple))"
>   : string

(*) val tabulate : int * (int -> 'a) -> 'a bag
Bag.tabulate;
> val it = fn : int * (int -> 'a) -> 'a bag
Bag.tabulate (5, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> val it = [1,1,2,6,24] : int bag
Bag.tabulate (1, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> val it = [1] : int bag
Bag.tabulate (0, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> val it = [] : int bag
Bag.tabulate (~1, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> uncaught exception Size
>   raised at: stdIn:1.1-1.86
Sys.plan ();
> val it =
>   "apply2(fnValue Bag.tabulate, constant(-1), let1(matchCode match(fact, match(n, apply(fnCode match(true, constant(1), _, apply2(fnValue *, get(name n), apply(fnCode link, argCode apply2(fnValue -, get(name n), constant(1))))), argCode apply2(fnValue =, get(name n), constant(0))))), resultCode get(name fact)))"
>   : string

(* Either ------------------------------------------------------ *)
Either;
> val it =
>   {app=fn,appLeft=fn,appRight=fn,asLeft=fn,asRight=fn,fold=fn,isLeft=fn,
>    isRight=fn,map=fn,mapLeft=fn,mapRight=fn,partition=fn,proj=fn}
>   : {app:('a -> unit) * ('b -> unit) -> ('a,'b) either -> unit,
>      appLeft:('c -> unit) -> ('c,'d) either -> unit,
>      appRight:('e -> unit) -> ('f,'e) either -> unit,
>      asLeft:('g,'h) either -> 'g option, asRight:('i,'j) either -> 'j option,
>      fold:('k * 'l -> 'l) * ('m * 'l -> 'l) -> 'l -> ('k,'m) either -> 'l,
>      isLeft:('n,'o) either -> bool, isRight:('p,'q) either -> bool,
>      map:('r -> 's) * ('t -> 'u) -> ('r,'t) either -> ('s,'u) either,
>      mapLeft:('v -> 'w) -> ('v,'x) either -> ('w,'x) either,
>      mapRight:('y -> 'z) -> ('ba,'y) either -> ('ba,'z) either,
>      partition:('bb,'bc) either list -> 'bb list * 'bc list,
>      proj:('bd,'bd) either -> 'bd}

val yes: (bool, int) either = INL true;
> val yes = INL true : (bool,int) either
val ten: (bool, int) either = INR 10;
> val ten = INR 10 : (bool,int) either

Either.isLeft;
> val it = fn : ('a,'b) either -> bool
Either.isLeft yes;
> val it = true : bool
Either.isLeft ten;
> val it = false : bool
Either.isRight;
> val it = fn : ('a,'b) either -> bool
Either.isRight yes;
> val it = false : bool
Either.isRight ten;
> val it = true : bool
Either.asLeft;
> val it = fn : ('a,'b) either -> 'a option
Either.asLeft yes;
> val it = SOME true : bool option
Either.asLeft ten;
> val it = NONE : bool option
Either.asRight;
> val it = fn : ('a,'b) either -> 'b option
Either.asRight yes;
> val it = NONE : int option
Either.asRight ten;
> val it = SOME 10 : int option
Either.map;
> val it = fn : ('a -> 'b) * ('c -> 'd) -> ('a,'c) either -> ('b,'d) either
Either.map (fn b => not b, fn i => i + 1) yes;
> val it = INL false : (bool,int) either
Either.map (fn b => not b, fn i => i + 1) ten;
> val it = INR 11 : (bool,int) either
Either.mapLeft;
> val it = fn : ('a -> 'b) -> ('a,'c) either -> ('b,'c) either
Either.mapLeft (fn b => not b) yes;
> val it = INL false : (bool,int) either
Either.mapLeft (fn b => not b) ten;
> val it = INR 10 : (bool,int) either
Either.mapRight;
> val it = fn : ('a -> 'b) -> ('c,'a) either -> ('c,'b) either
Either.mapRight (fn i => i + 1) yes;
> val it = INL true : (bool,int) either
Either.mapRight (fn i => i + 1) ten;
> val it = INR 11 : (bool,int) either
Either.app;
> val it = fn : ('a -> unit) * ('b -> unit) -> ('a,'b) either -> unit
Either.app (fn b => ignore (not b), fn i => ignore (i + 1)) yes;
> val it = () : unit
Either.app (fn b => ignore (not b), fn i => ignore (i + 1)) ten;
> val it = () : unit
Either.appLeft;
> val it = fn : ('a -> unit) -> ('a,'b) either -> unit
Either.appLeft (fn b => ignore (not b)) yes;
> val it = () : unit
Either.appLeft (fn b => ignore (not b)) ten;
> val it = () : unit
Either.appRight;
> val it = fn : ('a -> unit) -> ('b,'a) either -> unit
Either.appRight (fn i => ignore (i + 1)) yes;
> val it = () : unit
Either.appRight (fn i => ignore (i + 1)) ten;
> val it = () : unit
Either.fold;
> val it = fn : ('a * 'b -> 'b) * ('c * 'b -> 'b) -> 'b -> ('a,'c) either -> 'b
Either.fold (fn (b,i) => i + (if b then 2 else 1), fn (j,i) => j + i) 3 yes;
> val it = 5 : int
Either.fold (fn (b,i) => i + (if b then 2 else 1), fn (j,i) => j + i) 3 ten;
> val it = 13 : int
Either.proj;
> val it = fn : ('a,'a) either -> 'a
Either.proj (INL 5);
> val it = 5 : int
Either.proj (INR 7);
> val it = 7 : int
Either.partition;
> val it = fn : ('a,'b) either list -> 'a list * 'b list
Either.partition [yes, ten];
> val it = ([true],[10]) : bool list * int list

(* Fn ---------------------------------------------------------- *)
Fn;
> val it =
>   {apply=fn,const=fn,curry=fn,equal=fn,flip=fn,id=fn,notEqual=fn,`op o`=fn,
>    repeat=fn,uncurry=fn}
>   : {apply:('a -> 'b) * 'a -> 'b, const:'c -> 'd -> 'c,
>      curry:('e * 'f -> 'g) -> 'e -> 'f -> 'g, equal:'h -> 'h -> bool,
>      flip:('i * 'j -> 'k) -> 'j * 'i -> 'k, id:'l -> 'l,
>      notEqual:'m -> 'm -> bool, `op o`:('n -> 'o) * ('p -> 'n) -> 'p -> 'o,
>      repeat:int -> ('q -> 'q) -> 'q -> 'q,
>      uncurry:('r -> 's -> 't) -> 'r * 's -> 't}

Fn.id;
> val it = fn : 'a -> 'a
Fn.id "a";
> val it = "a" : string
Fn.const;
> val it = fn : 'a -> 'b -> 'a
Fn.const "b";
> val it = fn : 'a -> string
(* In SMLNJ, the previous line is
> val it = fn : ?.X1 -> string
*)
(Fn.const "b") false;
> val it = "b" : string
(Fn.const "b") 3.14;
> val it = "b" : string
(Fn.const "b") ();
> val it = "b" : string
Fn.apply;
> val it = fn : ('a -> 'b) * 'a -> 'b
Fn.apply (fn a => a + 3, 5);
> val it = 8 : int
Fn.curry;
> val it = fn : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
Fn.curry (fn (a, b) => a + b);
> val it = fn : int -> int -> int
Fn.curry (fn (a, b) => a + b) 3 5;
> val it = 8 : int
Fn.curry (fn (a, b) => a + b) 3;
> val it = fn : int -> int
Fn.uncurry;
> val it = fn : ('a -> 'b -> 'c) -> 'a * 'b -> 'c
Fn.uncurry (fn a => fn b => a + b);
> val it = fn : int * int -> int
Fn.uncurry (fn a => fn b => a + b) (3, 5);
> val it = 8 : int
Fn.flip;
> val it = fn : ('a * 'b -> 'c) -> 'b * 'a -> 'c
Fn.flip (fn (a, b) => a - b);
> val it = fn : int * int -> int
Fn.flip (fn (a, b) => a - b) (5, 3);
> val it = ~2 : int
Fn.repeat;
> val it = fn : int -> ('a -> 'a) -> 'a -> 'a
Fn.repeat 5 (fn i => i + 1);
> val it = fn : int -> int
it 8;
> val it = 13 : int
Fn.repeat 0 (fn i => i + 1);
> val it = fn : int -> int
it 8;
> val it = 8 : int
Fn.repeat ~2 (fn i => i + 1);
> uncaught exception Domain
>   raised at: stdIn:1.1-1.28
Fn.equal;
> val it = fn : 'a -> 'a -> bool
(* ^ SMLNJ gives
> val it = fn : ''a -> ''a -> bool
*)
Fn.equal 3 5;
> val it = false : bool
Fn.equal 3 3;
> val it = true : bool
Fn.notEqual;
> val it = fn : 'a -> 'a -> bool
(* ^ SMLNJ gives
> val it = fn : ''a -> ''a -> bool
*)
Fn.notEqual 3 5;
> val it = true : bool
Fn.notEqual 3 3;
> val it = false : bool

(* General ----------------------------------------------------- *)

(*) op o - function composition
val plusOne = fn x => x + 1;
> val plusOne = fn : int -> int
val timesTwo = fn x => x * 2;
> val timesTwo = fn : int -> int
val plusThree = fn x => x + 3;
> val plusThree = fn : int -> int
plusOne o timesTwo;
> val it = fn : int -> int
(plusOne o timesTwo) 3;
> val it = 7 : int
plusOne o timesTwo o plusThree;
> val it = fn : int -> int
((plusOne o timesTwo) o plusThree) 3;
> val it = 13 : int
(plusOne o (timesTwo o plusThree)) 3;
> val it = 13 : int
Sys.plan ();
> val it =
>   "apply(fnCode apply2(fnValue o, get(name plusOne), apply2(fnValue o, get(name timesTwo), get(name plusThree))), argCode constant(3))"
>   : string

ignore;
> val it = fn : 'a -> unit
ignore (1 + 2);
> val it = () : unit
Sys.plan ();
> val it =
>   "apply(fnValue General.ignore, argCode apply2(fnValue +, constant(1), constant(2)))"
>   : string

(* Interact ---------------------------------------------------- *)

(*) use - load source from a file
Interact.use;
> val it = fn : string -> unit
use;
> val it = fn : string -> unit

(* String ------------------------------------------------------ *)

(*) val maxSize : int
String.maxSize;
> val it = 2147483647 : int
Sys.plan ();
> val it = "constant(2147483647)" : string

(*) val size : string -> int
String.size;
> val it = fn : string -> int
String.size "abc";
> val it = 3 : int
String.size "";
> val it = 0 : int
Sys.plan ();
> val it = "apply(fnValue String.size, argCode constant())" : string

(*) val sub : string * int -> char
String.sub;
> val it = fn : string * int -> char
String.sub("abc", 0);
> val it = #"a" : char
String.sub("abc", 2);
> val it = #"c" : char
String.sub("abc", 20);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.22
String.sub("abc", 3);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.21
String.sub("abc", ~1);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.22
Sys.plan ();
> val it = "apply2(fnValue String.sub, constant(abc), constant(-1))" : string

(*) val extract: string * int * int option -> string
String.extract;
> val it = fn : string * int * int option -> string
String.extract("abc", 1, NONE);
> val it = "bc" : string
String.extract("abc", 1, SOME 2);
> val it = "bc" : string
String.extract("abc", 3, NONE);
> val it = "" : string
String.extract("abc", 3, SOME 0);
> val it = "" : string
String.extract("abc", 4, NONE);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.31
String.extract("abc", ~1, NONE);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.32
String.extract("abc", 4, SOME 2);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.33
String.extract("abc", ~1, SOME 2);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.34
String.extract("abc", 1, SOME ~1);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.34
String.extract("abc", 1, SOME 99);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.34
Sys.plan ();
> val it =
>   "apply3(fnValue String.extract, constant(abc), constant(1), apply(fnValue tyCon, argCode constant(99)))"
>   : string

(*) val substring : string * int * int -> string
String.substring;
> val it = fn : string * int * int -> string
String.substring("hello, world", 2, 7);
> val it = "llo, wo" : string
String.substring("hello, world", 0, 1);
> val it = "h" : string
String.substring("hello", 5, 0);
> val it = "" : string
String.substring("hello", 1, 4);
> val it = "ello" : string
String.substring("", 0, 0);
> val it = "" : string
String.substring("hello", ~1, 0);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.33
String.substring("hello", 1, ~1);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.33
String.substring("hello", 1, 5);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.32
Sys.plan ();
> val it =
>   "apply3(fnValue String.substring, constant(hello), constant(1), constant(5))"
>   : string

(*) val ^ : string * string -> string
String.`op ^`;
> val it = fn : string * string -> string
"a" ^ "bc";
> val it = "abc" : string
"a" ^ "";
> val it = "a" : string
"a" ^ "bc" ^ "" ^ "def";
> val it = "abcdef" : string
Sys.plan ();
> val it =
>   "apply2(fnValue ^, apply2(fnValue ^, apply2(fnValue ^, constant(a), constant(bc)), constant()), constant(def))"
>   : string

(*) val concat : string list -> string
String.concat;
> val it = fn : string list -> string
String.concat ["a", "bc", "def"];
> val it = "abcdef" : string
String.concat ["a"];
> val it = "a" : string
String.concat [];
> val it = "" : string
Sys.plan ();
> val it = "apply(fnValue String.concat, argCode tuple)" : string

(*) val concatWith : string -> string list -> string
String.concatWith;
> val it = fn : string -> string list -> string
String.concatWith "," ["a", "bc", "def"];
> val it = "a,bc,def" : string
String.concatWith "," ["a"];
> val it = "a" : string
String.concatWith "," ["", ""];
> val it = "," : string
String.concatWith "," [];
> val it = "" : string
Sys.plan ();
> val it = "apply2(fnValue String.concatWith, constant(,), tuple)" : string

(*) val str : char -> string
String.str;
> val it = fn : char -> string
String.str #"a";
> val it = "a" : string
Sys.plan ();
> val it = "apply(fnValue String.str, argCode constant(a))" : string

(*) val implode : char list -> string
String.implode;
> val it = fn : char list -> string
String.implode [#"a", #"b", #"c"];
> val it = "abc" : string
String.implode [];
> val it = "" : string
Sys.plan ();
> val it = "apply(fnValue String.implode, argCode tuple)" : string

(*) val explode : string -> char list
String.explode;
> val it = fn : string -> char list
String.explode "abc";
> val it = [#"a",#"b",#"c"] : char list
String.explode "";
> val it = [] : char list
Sys.plan ();
> val it = "apply(fnValue String.explode, argCode constant())" : string

(*) val map : (char -> char) -> string -> string
String.map;
> val it = fn : (char -> char) -> string -> string
String.map (fn c => if c = #"a" then #"A" else if c = #"c" then #"C" else c) "abc";
> val it = "AbC" : string
String.map (fn c => if c = #"a" then #"A" else if c = #"c" then #"C" else c) "";
> val it = "" : string
Sys.plan ();
> val it =
>   "apply2(fnValue String.map, match(c, apply(fnCode match(true, constant(A), _, apply(fnCode match(true, constant(C), _, get(name c)), argCode apply2(fnValue =, get(name c), constant(c)))), argCode apply2(fnValue =, get(name c), constant(a)))), constant())"
>   : string

(*) val translate : (char -> string) -> string -> string
String.translate;
> val it = fn : (char -> string) -> string -> string
String.translate (fn c => if c = #"a" then "AA" else if c = #"c" then "CCC" else "-") "abc";
> val it = "AA-CCC" : string
String.translate (fn c => if c = #"a" then "AA" else if c = #"c" then "CCC" else "-") "";
> val it = "" : string
Sys.plan ();
> val it =
>   "apply2(fnValue String.translate, match(c, apply(fnCode match(true, constant(AA), _, apply(fnCode match(true, constant(CCC), _, constant(-)), argCode apply2(fnValue =, get(name c), constant(c)))), argCode apply2(fnValue =, get(name c), constant(a)))), constant())"
>   : string

(*) val tokens : (char -> bool) -> string -> string list
String.tokens;
> val it = fn : (char -> bool) -> string -> string list
String.tokens (fn c => c = #"|") "|ab||cd";
> val it = ["ab","cd"] : string list
String.tokens (fn c => c = #"|") "a|b||";
> val it = ["a","b"] : string list
String.tokens (fn c => c = #"|") "";
> val it = [] : string list

(*) val fields : (char -> bool) -> string -> string list
String.fields;
> val it = fn : (char -> bool) -> string -> string list
String.fields (fn c => c = #"|") "|ab||cd";
> val it = ["","ab","","cd"] : string list
String.fields (fn c => c = #"|") "a|b||";
> val it = ["a","b","",""] : string list
String.fields (fn c => c = #"|") "";
> val it = [""] : string list

(*) val isPrefix    : string -> string -> bool
String.isPrefix;
> val it = fn : string -> string -> bool
String.isPrefix "he" "hello";
> val it = true : bool
String.isPrefix "el" "hello";
> val it = false : bool
String.isPrefix "lo" "hello";
> val it = false : bool
String.isPrefix "bonjour" "hello";
> val it = false : bool
String.isPrefix "el" "";
> val it = false : bool
String.isPrefix "" "hello";
> val it = true : bool
String.isPrefix "" "";
> val it = true : bool
Sys.plan ();
> val it = "apply2(fnValue String.isPrefix, constant(), constant())" : string

(*) Partial evaluation
val p = String.isPrefix "he";
> val p = fn : string -> bool
Sys.plan ();
> val it = "apply1(fnValue String.isPrefix, constant(he))" : string
p "hello";
> val it = true : bool
p "goodbye";
> val it = false : bool

(*) val isSubstring : string -> string -> bool
String.isSubstring;
> val it = fn : string -> string -> bool
String.isSubstring "he" "hello";
> val it = true : bool
String.isSubstring "el" "hello";
> val it = true : bool
String.isSubstring "lo" "hello";
> val it = true : bool
String.isSubstring "bonjour" "hello";
> val it = false : bool
String.isSubstring "el" "";
> val it = false : bool
String.isSubstring "" "hello";
> val it = true : bool
String.isSubstring "" "";
> val it = true : bool
Sys.plan ();
> val it = "apply2(fnValue String.isSubstring, constant(), constant())" : string

(*) val isSuffix    : string -> string -> bool
String.isSuffix;
> val it = fn : string -> string -> bool
String.isSuffix "he" "hello";
> val it = false : bool
String.isSuffix "el" "hello";
> val it = false : bool
String.isSuffix "lo" "hello";
> val it = true : bool
String.isSuffix "bonjour" "hello";
> val it = false : bool
String.isSuffix "el" "";
> val it = false : bool
String.isSuffix "" "hello";
> val it = true : bool
String.isSuffix "" "";
> val it = true : bool
Sys.plan ();
> val it = "apply2(fnValue String.isSuffix, constant(), constant())" : string

(*) val compare : string * string -> order
String.compare;
> val it = fn : string * string -> order
String.compare ("abc", "ab");
> val it = GREATER : order

(*) val collate : (char * char -> order) -> string * string -> order
String.collate;
> val it = fn : (char * char -> order) -> string * string -> order
let
  fun charCompareIgnoreCase (c1, c2) =
      Char.compare (Char.toLower c1, Char.toLower c2)
in
  String.collate charCompareIgnoreCase ("Hello", "hello")
end;
> val it = EQUAL : order
String.collate Char.compare ("Hello", "hello");
> val it = LESS : order
let
  fun charCompareIgnoreCase (c1, c2) =
      Char.compare (Char.toLower c1, Char.toLower c2)
in
  String.collate charCompareIgnoreCase ("Apple", "BANANA")
end;
> val it = LESS : order

(*) val <  : string * string -> bool
String.`op <`;
> val it = fn : string * string -> bool
"abc" < "ab";
> val it = false : bool
"ab" < "ab";
> val it = false : bool

(*) val <= : string * string -> bool
String.`op <=`;
> val it = fn : string * string -> bool
"abc" <= "ab";
> val it = false : bool
"ab" <= "ab";
> val it = true : bool

(*) val >  : string * string -> bool
String.`op >`;
> val it = fn : string * string -> bool
"abc" > "ab";
> val it = true : bool
"ab" > "ab";
> val it = false : bool

(*) val >= : string * string -> bool
String.`op >=`;
> val it = fn : string * string -> bool
"abc" >= "ab";
> val it = true : bool
"ab" >= "ab";
> val it = true : bool

(*) val toString : string -> String.string
(*) val scan       : (char, 'a) StringCvt.reader
(*)                    -> (string, 'a) StringCvt.reader
(*) val fromString : String.string -> string option
(*) val toCString : string -> String.string
(*) val fromCString : String.string -> string option

(* List -------------------------------------------------------- *)

(*) val nil : 'a list
List.nil;
> val it = [] : 'a list
Sys.plan ();
> val it = "constant([])" : string

(*) val null : 'a list -> bool
List.null;
> val it = fn : 'a list -> bool
List.null [];
> val it = true : bool
List.null [1];
> val it = false : bool
Sys.plan ();
> val it = "apply(fnValue List.null, argCode tuple(constant(1)))" : string

(*) val length : 'a list -> int
List.length;
> val it = fn : 'a list -> int
List.length [];
> val it = 0 : int
List.length [1,2];
> val it = 2 : int
Sys.plan ();
> val it = "apply(fnValue List.length, argCode tuple(constant(1), constant(2)))"
>   : string

(*) val @ : 'a list * 'a list -> 'a list
List.at;
> val it = fn : 'a list * 'a list -> 'a list
List.at ([1], [2, 3]);
> val it = [1,2,3] : int list
List.at ([1], []);
> val it = [1] : int list
List.at ([], [2]);
> val it = [2] : int list
List.at ([], []);
> val it = [] : 'a list
Sys.plan ();
> val it = "apply2(fnValue List.at, tuple, tuple)" : string

[1] @ [2, 3];
> val it = [1,2,3] : int list
[] @ [];
> val it = [] : 'a list
Sys.plan ();
> val it = "apply2(fnValue List.at, tuple, tuple)" : string

(*) val hd : 'a list -> 'a
List.hd;
> val it = fn : 'a list -> 'a
List.hd [1,2,3];
> val it = 1 : int
List.hd [];
> uncaught exception Empty
>   raised at: stdIn:1.1-1.11
Sys.plan ();
> val it = "apply(fnValue List.hd, argCode tuple)" : string

(*) val tl : 'a list -> 'a list
List.tl;
> val it = fn : 'a list -> 'a list
List.tl [1,2,3];
> val it = [2,3] : int list
List.tl [];
> uncaught exception Empty
>   raised at: stdIn:1.1-1.11
Sys.plan ();
> val it = "apply(fnValue List.tl, argCode tuple)" : string

(*) val last : 'a list -> 'a
List.last;
> val it = fn : 'a list -> 'a
List.last [1,2,3];
> val it = 3 : int
List.last [];
> uncaught exception Empty
>   raised at: stdIn:1.1-1.13
Sys.plan ();
> val it = "apply(fnValue List.last, argCode tuple)" : string

(*) val getItem : 'a list -> ('a * 'a list) option
List.getItem;
> val it = fn : 'a list -> ('a * 'a list) option
List.getItem [1,2,3];
> val it = SOME (1,[2,3]) : (int * int list) option
List.getItem [1];
> val it = SOME (1,[]) : (int * int list) option
Sys.plan ();
> val it = "apply(fnValue List.getItem, argCode tuple(constant(1)))" : string

(*) val nth : 'a list * int -> 'a
List.nth;
> val it = fn : 'a list * int -> 'a
List.nth ([1,2,3], 2);
> val it = 3 : int
List.nth ([1], 0);
> val it = 1 : int
List.nth ([1,2,3], 3);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.22
List.nth ([1,2,3], ~1);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.23
Sys.plan ();
> val it =
>   "apply2(fnValue List.nth, tuple(constant(1), constant(2), constant(3)), constant(-1))"
>   : string

(*) val take : 'a list * int -> 'a list
List.`take`;
> val it = fn : 'a list * int -> 'a list
List.`take` ([1,2,3], 0);
> val it = [] : int list
List.`take` ([1,2,3], 1);
> val it = [1] : int list
List.`take` ([1,2,3], 3);
> val it = [1,2,3] : int list
List.`take` ([1,2,3], 4);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.25
List.`take` ([1,2,3], ~1);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.26
Sys.plan ();
> val it =
>   "apply2(fnValue List.take, tuple(constant(1), constant(2), constant(3)), constant(-1))"
>   : string

(*) val drop : 'a list * int -> 'a list
List.drop;
> val it = fn : 'a list * int -> 'a list
List.drop ([1,2,3], 0);
> val it = [1,2,3] : int list
List.drop ([1,2,3], 1);
> val it = [2,3] : int list
List.drop ([1,2,3], 3);
> val it = [] : int list
Sys.plan ();
> val it =
>   "apply2(fnValue List.drop, tuple(constant(1), constant(2), constant(3)), constant(3))"
>   : string

(*) val rev : 'a list -> 'a list
List.rev;
> val it = fn : 'a list -> 'a list
List.rev [1,2,3];
> val it = [3,2,1] : int list
List.rev [2,1];
> val it = [1,2] : int list
List.rev [1];
> val it = [1] : int list
List.rev [];
> val it = [] : 'a list
Sys.plan ();
> val it = "apply(fnValue List.rev, argCode tuple)" : string

(*) val concat : 'a list list -> 'a list
List.concat;
> val it = fn : 'a list list -> 'a list
List.concat [[1],[2,3],[4,5,6]];
> val it = [1,2,3,4,5,6] : int list
List.concat [[1],[],[4,5,6]];
> val it = [1,4,5,6] : int list
List.concat [[],[],[]];
> val it = [] : 'a list
List.concat [];
> val it = [] : 'a list
Sys.plan ();
> val it = "apply(fnValue List.concat, argCode tuple)" : string

(*) val revAppend : 'a list * 'a list -> 'a list
List.revAppend;
> val it = fn : 'a list * 'a list -> 'a list
List.revAppend ([1,2],[3,4,5]);
> val it = [2,1,3,4,5] : int list
List.revAppend ([1],[3,4,5]);
> val it = [1,3,4,5] : int list
List.revAppend ([],[3,4,5]);
> val it = [3,4,5] : int list
List.revAppend ([1,2],[]);
> val it = [2,1] : int list
List.revAppend ([],[]);
> val it = [] : 'a list
Sys.plan ();
> val it = "apply2(fnValue List.revAppend, tuple, tuple)" : string

(*) val app : ('a -> unit) -> 'a list -> unit
List.app;
> val it = fn : ('a -> unit) -> 'a list -> unit
List.app (fn x => ignore (x + 2)) [2,3,4];
> val it = () : unit
List.app (fn x => ignore (x + 2)) [];
> val it = () : unit
Sys.plan ();
> val it =
>   "apply2(fnValue List.app, match(x, apply(fnValue General.ignore, argCode apply2(fnValue +, get(name x), constant(2)))), tuple)"
>   : string

(*) val mapi : (int * 'a -> 'b) -> 'a list -> 'b list
List.mapi;
> val it = fn : (int * 'a -> 'b) -> 'a list -> 'b list
List.mapi (fn (i, s) => String.sub (s, i)) ["abc", "xyz"];
> val it = [#"a",#"y"] : char list
Sys.plan ();
> val it =
>   "apply2(fnValue List.mapi, match(v, apply(fnCode match((i, s), apply2(fnValue String.sub, get(name s), get(name i))), argCode get(name v))), tuple(constant(abc), constant(xyz)))"
>   : string

(*) val map : ('a -> 'b) -> 'a list -> 'b list
List.map;
> val it = fn : ('a -> 'b) -> 'a list -> 'b list
List.map (fn x => x + 1) [1,2,3];
> val it = [2,3,4] : int list
List.map (fn x => x + 1) [];
> val it = [] : int list
Sys.plan ();
> val it =
>   "apply2(fnValue List.map, match(x, apply2(fnValue +, get(name x), constant(1))), tuple)"
>   : string

(*) map is alias for List.map
map;
> val it = fn : ('a -> 'b) -> 'a list -> 'b list
map (fn x => x) [];
> val it = [] : 'a list
Sys.plan ();
> val it = "apply2(fnValue List.map, match(x, get(name x)), tuple)" : string

(*) val mapPartial : ('a -> 'b option) -> 'a list -> 'b list
List.mapPartial;
> val it = fn : ('a -> 'b option) -> 'a list -> 'b list
List.mapPartial (fn x => if x mod 2 = 0 then NONE else SOME (x + 1)) [1,2,3,5,8];
> val it = [2,4,6] : int list
List.mapPartial (fn x => if x mod 2 = 0 then NONE else SOME (x + 1)) [];
> val it = [] : int list
Sys.plan ();
> val it =
>   "apply2(fnValue List.mapPartial, match(x, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply2(fnValue +, get(name x), constant(1)))), argCode apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0)))), tuple)"
>   : string

(*) val find : ('a -> bool) -> 'a list -> 'a option
List.find;
> val it = fn : ('a -> bool) -> 'a list -> 'a option
List.find (fn x => x mod 7 = 0) [2,3,5,8,13,21,34];
> val it = SOME 21 : int option
List.find (fn x => x mod 11 = 0) [2,3,5,8,13,21,34];
> val it = NONE : int option
Sys.plan ();
> val it =
>   "apply2(fnValue List.find, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(11)), constant(0))), tuple(constant(2), constant(3), constant(5), constant(8), constant(13), constant(21), constant(34)))"
>   : string

(*) val filter : ('a -> bool) -> 'a list -> 'a list
List.filter;
> val it = fn : ('a -> bool) -> 'a list -> 'a list
List.filter (fn x => x mod 2 = 0) [0,1,2,3,4,5];
> val it = [0,2,4] : int list
List.filter (fn x => x mod 2 = 0) [1,3];
> val it = [] : int list
List.filter (fn x => x mod 2 = 0) [];
> val it = [] : int list
Sys.plan ();
> val it =
>   "apply2(fnValue List.filter, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), tuple)"
>   : string

(*) val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
List.partition;
> val it = fn : ('a -> bool) -> 'a list -> 'a list * 'a list
List.partition (fn x => x mod 2 = 0) [0,1,2,3,4,5];
> val it = ([0,2,4],[1,3,5]) : int list * int list
List.partition (fn x => x mod 2 = 0) [1];
> val it = ([],[1]) : int list * int list
List.partition (fn x => x mod 2 = 0) [];
> val it = ([],[]) : int list * int list
Sys.plan ();
> val it =
>   "apply2(fnValue List.partition, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), tuple)"
>   : string

(*) val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
List.foldl;
> val it = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
List.foldl (fn (a, b) => a + b) 0 [1,2,3];
> val it = 6 : int
List.foldl (fn (a, b) => a + b) 0 [];
> val it = 0 : int
List.foldl (fn (a, b) => b) 0 [1,2,3];
> val it = 0 : int
List.foldl (fn (a, b) => a - b) 0 [1,2,3,4];
> val it = 2 : int
Sys.plan ();
> val it =
>   "apply3(fnValue List.foldl, match(v, apply(fnCode match((a, b), apply2(fnValue -, get(name a), get(name b))), argCode get(name v))), constant(0), tuple(constant(1), constant(2), constant(3), constant(4)))"
>   : string

(*) val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
List.foldr;
> val it = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
List.foldr (fn (a, b) => a + b) 0 [1,2,3];
> val it = 6 : int
List.foldr (fn (a, b) => a + b) 0 [];
> val it = 0 : int
List.foldr (fn (a, b) => b) 0 [1,2,3];
> val it = 0 : int
List.foldr (fn (a, b) => a - b) 0 [1,2,3,4];
> val it = ~2 : int
Sys.plan ();
> val it =
>   "apply3(fnValue List.foldr, match(v, apply(fnCode match((a, b), apply2(fnValue -, get(name a), get(name b))), argCode get(name v))), constant(0), tuple(constant(1), constant(2), constant(3), constant(4)))"
>   : string

(*) val exists : ('a -> bool) -> 'a list -> bool
List.`exists`;
> val it = fn : ('a -> bool) -> 'a list -> bool
List.`exists` (fn x => x mod 2 = 0) [1,3,5];
> val it = false : bool
List.`exists` (fn x => x mod 2 = 0) [2,4,6];
> val it = true : bool
List.`exists` (fn x => x mod 2 = 0) [1,2,3];
> val it = true : bool
List.`exists` (fn x => x mod 2 = 0) [];
> val it = false : bool
Sys.plan ();
> val it =
>   "apply2(fnValue List.exists, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), tuple)"
>   : string

(*) val all : ('a -> bool) -> 'a list -> bool
List.all;
> val it = fn : ('a -> bool) -> 'a list -> bool
List.all (fn x => x mod 2 = 0) [1,3,5];
> val it = false : bool
List.all (fn x => x mod 2 = 0) [2,4,6];
> val it = true : bool
List.all (fn x => x mod 2 = 0) [1,2,3];
> val it = false : bool
List.all (fn x => x mod 2 = 0) [];
> val it = true : bool
Sys.plan ();
> val it =
>   "apply2(fnValue List.all, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), tuple)"
>   : string

(*) val tabulate : int * (int -> 'a) -> 'a list
List.tabulate;
> val it = fn : int * (int -> 'a) -> 'a list
List.tabulate (5, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> val it = [1,1,2,6,24] : int list
List.tabulate (1, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> val it = [1] : int list
List.tabulate (0, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> val it = [] : int list
List.tabulate (~1, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> uncaught exception Size
>   raised at: stdIn:1.1-1.87
Sys.plan ();
> val it =
>   "apply2(fnValue List.tabulate, constant(-1), let1(matchCode match(fact, match(n, apply(fnCode match(true, constant(1), _, apply2(fnValue *, get(name n), apply(fnCode link, argCode apply2(fnValue -, get(name n), constant(1))))), argCode apply2(fnValue =, get(name n), constant(0))))), resultCode get(name fact)))"
>   : string

(*) val collate : ('a * 'a -> order) -> 'a list * 'a list -> order
List.collate;
> val it = fn : ('a * 'a -> order) -> 'a list * 'a list -> order
List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1, 2,3], [1,3,4]);
> val it = LESS : order
List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2,2]);
> val it = GREATER : order
List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2]);
> val it = GREATER : order
List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2,3,4]);
> val it = LESS : order
List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], []);
> val it = GREATER : order
List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([], []);
> val it = EQUAL : order
Sys.plan ();
> val it =
>   "apply2(fnValue List.collate, match(v, apply(fnCode match((x, y), apply(fnCode match(true, constant([LESS]), _, apply(fnCode match(true, constant([EQUAL]), _, constant([GREATER])), argCode apply2(fnValue =, get(name x), get(name y)))), argCode apply2(fnValue <, get(name x), get(name y)))), argCode get(name v))), tuple(tuple, tuple))"
>   : string

(* ListPair ---------------------------------------------------- *)

(* The ListPair structure provides operations on pairs of lists. The
   operations fall into two categories. Those in the first category,
   whose names do not end in "Eq", do not require that the lists have
   the same length. When the lists are of uneven lengths, the excess
   elements from the tail of the longer list are ignored. The
   operations in the second category, whose names have the suffix
   "Eq", differ from their similarly named operations in the first
   category only when the list arguments have unequal lengths, in
   which case they typically raise the UnequalLengths exception.

   There are three groups of functions:
    * zip, map, app, all, exists, foldr and foldl raise no exception
      when the argument lists are found to be of unequal length; the
      excess elements from the longer list are simply disregarded.
    * zipEq, mapEq, appEq, foldrEq and foldlEq raise exception
      UnequalLengths when the argument lists are found to be of
      unequal length.
    * allEq raises no exception but returns false if the lists are
      found to have unequal lengths (after traversing the lists).
*)
ListPair;
> val it =
>   {all=fn,allEq=fn,app=fn,appEq=fn,exists=fn,foldl=fn,foldlEq=fn,foldr=fn,
>    foldrEq=fn,map=fn,mapEq=fn,unzip=fn,zip=fn,zipEq=fn}
>   : {all:('a * 'b -> bool) -> 'a list * 'b list -> bool,
>      allEq:('c * 'd -> bool) -> 'c list * 'd list -> bool,
>      app:('e * 'f -> unit) -> 'e list * 'f list -> unit,
>      appEq:('g * 'h -> unit) -> 'g list * 'h list -> unit,
>      exists:('i * 'j -> bool) -> 'i list * 'j list -> bool,
>      foldl:('k * 'l * 'm -> 'm) -> 'm -> 'k list * 'l list -> 'm,
>      foldlEq:('n * 'o * 'p -> 'p) -> 'p -> 'n list * 'o list -> 'p,
>      foldr:('q * 'r * 's -> 's) -> 's -> 'q list * 'r list -> 's,
>      foldrEq:('t * 'u * 'v -> 'v) -> 'v -> 't list * 'u list -> 'v,
>      map:('w * 'x -> 'y) -> 'w list * 'x list -> 'y list,
>      mapEq:('z * 'ba -> 'bb) -> 'z list * 'ba list -> 'bb list,
>      unzip:('bc * 'bd) list -> 'bc list * 'bd list,
>      zip:'be list * 'bf list -> ('be * 'bf) list,
>      zipEq:'bg list * 'bh list -> ('bg * 'bh) list}

(* [all p (xs, ys)] applies predicate p to the pairs of corresponding
   elements of xs and ys from left to right until p evaluates to false
   or one or both lists is exhausted; returns true if p is true of all
   such pairs; otherwise false.  Hence all p (xs, ys) has the same
   result and effect as List.all p (zip (xs, ys)). *)
ListPair.all;
> val it = fn : ('a * 'b -> bool) -> 'a list * 'b list -> bool

ListPair.all (fn (x, y) => x < y) ([1, 2, 3], [2, 3, 4]);
> val it = true : bool
ListPair.all (fn (x, y) => x < y) ([1, 2, 3], [2, 3]);
> val it = true : bool
ListPair.all (fn (x, y) => x < y) ([1, 2, 3], [2, 3, 4, 5]);
> val it = true : bool
ListPair.all (fn (x, y) => x < y) ([1, 2, 3], [2, 2, 4, 5, 6]);
> val it = false : bool

(* [allEq p (xs, ys)] works as all p (xs, ys) but returns false if xs
   and ys do not have the same length.  Equivalent to all p (xs, ys)
   andalso length xs = length ys. *)
ListPair.allEq;
> val it = fn : ('a * 'b -> bool) -> 'a list * 'b list -> bool
ListPair.allEq (fn (x, y) => x < y) ([1, 2, 3], [2, 3, 4]);
> val it = true : bool
ListPair.allEq (fn (x, y) => x < y) ([1, 2, 3], [2, 3]);
> val it = false : bool
ListPair.allEq (fn (x, y) => x < y) ([1, 2, 3], [2, 3, 4, 5]);
> val it = false : bool
ListPair.allEq (fn (x, y) => x < y) ([1, 5, 3], [2, 3, 4]);
> val it = false : bool

(* [app f (xs, ys)] applies function f to the pairs of corresponding
   elements of xs and ys from left to right and returns ().  Hence app
   f (xs, ys) has the same result and effect as List.app f (zip (xs,
   ys)). *)
ListPair.app;
> val it = fn : ('a * 'b -> unit) -> 'a list * 'b list -> unit
ListPair.app (fn (x, y) => print (Int.toString x ^ " " ^ Int.toString y ^ "\n")) ([1, 2, 3], [4, 5, 6]);
> val it = () : unit
ListPair.app (fn (x, y) => print (Int.toString x ^ " " ^ Int.toString y ^ "\n")) ([1, 2, 3], [4]);
> val it = () : unit

(* [appEq f (xs, ys)] applies function f to pairs of corresponding
   elements of xs and ys from left to right, and then raises
   UnequalLengths if xs and ys have the same length. *)
ListPair.appEq;
> val it = fn : ('a * 'b -> unit) -> 'a list * 'b list -> unit
ListPair.appEq (fn (x, y) => print (Int.toString x ^ " " ^ Int.toString y ^ "\n")) ([1, 2, 3], [4, 5, 6]);
> val it = () : unit
ListPair.appEq (fn (x, y) => print (Int.toString x ^ " " ^ Int.toString y ^ "\n")) ([1, 2, 3], [4, 5]);
> uncaught exception UnequalLengths
>   raised at: stdIn:1.1-1.103

(* [exists p (xs, ys)] applies predicate p to the pairs of
   corresponding elements of xs and ys from left to right until p
   evaluates to true or one or both lists is exhausted; returns true
   if p is true of any such pair; otherwise false.  Hence exists p
   (xs, ys) has the same result and effect as List.exists p (zip (xs,
   ys)).  Also, exists p (xs, ys) is equivalent to not(all (not o p)
   (xs, ys)). *)
ListPair.`exists`;
> val it = fn : ('a * 'b -> bool) -> 'a list * 'b list -> bool
ListPair.`exists` (fn (x, y) => x < y) ([1, 2, 3], [2, 3, 4]);
> val it = true : bool
ListPair.`exists` (fn (x, y) => x < y) ([1, 2, 3], [2, 3]);
> val it = true : bool
ListPair.`exists` (fn (x, y) => x < y) ([1, 2, 3], [2, 3, 4, 5]);
> val it = true : bool
ListPair.`exists` (fn (x, y) => x < y) ([1, 2, 3], [1, 1, 2, 5, 6]);
> val it = false : bool
ListPair.`exists` (fn (x, y) => x < y) ([1, 2, 3], []);
> val it = false : bool

(* [foldl f e (xs, ys)] evaluates f(xn, yn, f( ..., f(x2, y2, f(x1,
   y1, e)))) where xs = [x1, x2, ..., x(n-1), xn, ...], ys = [y1, y2,
   ..., y(n-1), yn, ...], and n = min(length xs, length ys).
   Equivalent to List.foldl (fn ((x, y), r) => f(x, y, r)) e (zip(xs,
   ys)). *)
ListPair.foldl;
> val it = fn : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
ListPair.foldl (fn (x, y, r) => x + y + r) 0 ([1, 2, 3], [4, 5, 6]);
> val it = 21 : int
ListPair.foldl (fn (x, y, r) => x + y + r) 0 ([1, 2], [4, 5, 6]);
> val it = 12 : int

(* [foldlEq f e (xs, ys)] evaluates f(xn, yn, f( ..., f(x2, y2, f(x1,
   y1, e)))) where xs = [x1, x2, ..., x(n-1), xn, ...], ys = [y1, y2,
   ..., y(n-1), yn, ...], and n = min(length xs, length ys).  Then
   raises UnequalLengths if xs and ys do not have the same length.  If
   f has no side effects and terminates normally, then it is
   equivalent to List.foldl (fn ((x,y),r) => f(x,y,r)) e (zipEq(xs,
   ys)). *)
ListPair.foldlEq;
> val it = fn : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
ListPair.foldlEq (fn (x, y, r) => x + y + r) 0 ([1, 2, 3], [4, 5, 6]);
> val it = 21 : int
ListPair.foldlEq (fn (x, y, r) => x + y + r) 0 ([1, 2], [4, 5, 6]);
> uncaught exception UnequalLengths
>   raised at: stdIn:1.1-1.67

(* [foldr f e (xs, ys)] evaluates f(x1, y1, f(x2, y2, f(..., f(xn, yn,
   e)))) where xs = [x1, x2, ..., x(n-1), xn, ...], ys = [y1, y2, ...,
   y(n-1), yn, ...], and n = min(length xs, length ys).  Equivalent to
   List.foldr (fn ((x, y), r) => f(x, y, r)) e (zip(xs, ys)). *)
ListPair.foldr;
> val it = fn : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
ListPair.foldr (fn (x, y, r) => x + y + r) 0 ([1, 2, 3], [4, 5, 6]);
> val it = 21 : int
ListPair.foldr (fn (x, y, r) => x + y + r) 0 ([1, 2], [4, 5, 6]);
> val it = 12 : int

(* [foldrEq f e (xs, ys)] raises UnequalLengths if xs and ys do not
   have the same length.  Otherwise evaluates f(x1, y1, f(x2, y2,
   f(..., f(xn, yn, e)))) where xs = [x1, x2, ..., x(n-1), xn], ys =
   [y1, y2, ..., y(n-1), yn], and n = length xs = length ys.
   Equivalent to List.foldr (fn ((x,y),r) => f(x,y,r)) e (zipEq(xs,
   ys)). *)
ListPair.foldrEq;
> val it = fn : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
ListPair.foldrEq (fn (x, y, r) => x + y + r) 0 ([1, 2, 3], [4, 5, 6]);
> val it = 21 : int
ListPair.foldrEq (fn (x, y, r) => x + y + r) 0 ([1, 2], [4, 5, 6]);
> uncaught exception UnequalLengths
>   raised at: stdIn:1.1-1.67

(* [map f (xs, ys)] applies function f to the pairs of corresponding
   elements of xs and ys from left to right and returns the list of
   results.  Hence map f (xs, ys) has the same result and effect as
   List.map f (zip (xs, ys)). *)
ListPair.map;
> val it = fn : ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list
ListPair.map (fn (x, y) => x + y) ([1, 2, 3], [4, 5, 6]);
> val it = [5,7,9] : int list
ListPair.map (fn (x, y) => x + y) ([1, 2, 3], [4, 5]);
> val it = [5,7] : int list
ListPair.map (fn (x, y) => x + y) ([], [4, 5]);
> val it = [] : int list

(* [mapEq f (xs, ys)] applies function f to pairs of corresponding
   elements of xs and ys from left to right, and then returns the list
   of results if xs and ys have the same length, otherwise raises
   UnequalLengths.  If f has no side effects and terminates, then it
   is equivalent to List.map f (zipEq (xs, ys)). *)
ListPair.mapEq;
> val it = fn : ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list
ListPair.mapEq (fn (x, y) => x + y) ([1, 2, 3], [4, 5, 6]);
> val it = [5,7,9] : int list
ListPair.mapEq (fn (x, y) => x + y) ([1, 2, 3], [4, 5]);
> uncaught exception UnequalLengths
>   raised at: stdIn:1.1-1.56
ListPair.mapEq (fn (x, y) => x + y) ([], [4, 5]);
> uncaught exception UnequalLengths
>   raised at: stdIn:1.1-1.49

(* [unzip xys] returns a pair (xs, ys), where xs is the list of first
   components of xys, and ys is the list of second components from
   xys.  Hence zip (unzip xys) has the same result and effect as
   xys. *)
ListPair.unzip;
> val it = fn : ('a * 'b) list -> 'a list * 'b list
ListPair.unzip [(1, "a"), (2, "b"), (3, "c")];
> val it = ([1,2,3],["a","b","c"]) : int list * string list

(* [zip (xs, ys)] returns the list of pairs of corresponding elements
   from xs and ys. *)
ListPair.zip;
> val it = fn : 'a list * 'b list -> ('a * 'b) list
ListPair.zip ([1, 2, 3], ["a", "b", "c"]);
> val it = [(1,"a"),(2,"b"),(3,"c")] : (int * string) list
ListPair.zip ([1, 2, 3], ["a", "b"]);
> val it = [(1,"a"),(2,"b")] : (int * string) list
ListPair.zip ([], ["a", "b"]);
> val it = [] : ('a * string) list

(* [zipEq (xs, ys)] returns the list of pairs of corresponding
   elements from xs and ys.  Raises UnequalLengths if xs and ys do not
   have the same length. *)
ListPair.zipEq;
> val it = fn : 'a list * 'b list -> ('a * 'b) list
ListPair.zipEq ([1, 2, 3], ["a", "b", "c"]);
> val it = [(1,"a"),(2,"b"),(3,"c")] : (int * string) list
ListPair.zipEq ([1, 2, 3], ["a", "b"]);
> uncaught exception UnequalLengths
>   raised at: stdIn:1.1-1.39
ListPair.zipEq ([], ["a", "b"]);
> uncaught exception UnequalLengths
>   raised at: stdIn:1.1-1.32

(* Math -------------------------------------------------------- *)
(* The signature MATH specifies basic mathematical constants, the
   square root function, and trigonometric, hyperbolic, exponential,
   and logarithmic functions based on a real type. The functions
   defined here have roughly the same semantics as their counterparts
   in ISO C's math.h.

   In the functions below, unless specified otherwise, if any argument
   is a NaN, the return value is a NaN. In a list of rules specifying
   the behavior of a function in special cases, the first matching
   rule defines the semantics. *)

(* "acos x" returns the arc cosine of x. acos is the inverse of cos.
   Its result is guaranteed to be in the closed interval [0, pi]. If
   the magnitude of x exceeds 1.0, returns NaN. *)
Math.acos;
> val it = fn : real -> real
Math.acos 1.0;
> val it = 0.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.acos, argCode constant(1.0))" : string
List.map (fn x => (x, Math.acos x))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, Math.sqrt 0.5, 2.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,0.0),(0.0,1.5707964),(~0.0,1.5707964),(~1.0,3.1415927),(0.5,1.0471976),
>    (0.70710677,0.7853982),(2.0,nan),(inf,nan),(~inf,nan),(nan,nan)]
>   : (real * real) list

(* "asin x" returns the arc sine of x. asin is the inverse of sin. Its
   result is guaranteed to be in the closed interval [-pi / 2, pi / 2].
   If the magnitude of x exceeds 1.0, returns NaN. *)
Math.asin;
> val it = fn : real -> real
Math.asin 1.0;
> val it = 1.5707964 : real
Sys.plan ();
> val it = "apply(fnValue Math.asin, argCode constant(1.0))" : string
List.map (fn x => (x, Math.asin x))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, Math.sqrt 0.5, 2.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,1.5707964),(0.0,0.0),(~0.0,~0.0),(~1.0,~1.5707964),(0.5,0.5235988),
>    (0.70710677,0.7853981),(2.0,nan),(inf,nan),(~inf,nan),(nan,nan)]
>   : (real * real) list

(* "atan x" returns the arc tangent of x. atan is the inverse of
   tan. For finite arguments, the result is guaranteed to be in the
   open interval (-pi / 2, pi / 2). If x is +infinity, it returns pi / 2;
   if x is -infinity, it returns -pi / 2. *)
Math.atan;
> val it = fn : real -> real
Math.atan 0.0;
> val it = 0.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.atan, argCode constant(0.0))" : string
List.map (fn x => (x, Math.atan x))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, Math.sqrt 0.5, 2.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,0.7853982),(0.0,0.0),(~0.0,~0.0),(~1.0,~0.7853982),(0.5,0.4636476),
>    (0.70710677,0.6154797),(2.0,1.1071488),(inf,1.5707964),(~inf,~1.5707964),
>    (nan,nan)] : (real * real) list

(* "atan2 (y, x)" returns the arc tangent of (y / x) in the closed
   interval [-pi, pi], corresponding to angles within +-180
   degrees. The quadrant of the resulting angle is determined using
   the signs of both x and y, and is the same as the quadrant of the
   point (x, y). When x = 0, this corresponds to an angle of 90
   degrees, and the result is (real (sign y)) * pi / 2.0. It holds
   that
     sign (cos (atan2 (y, x))) = sign (x)
   and
     sign (sin (atan2 (y, x))) = sign (y)
   except for inaccuracies incurred by the finite precision of real
   and the approximation algorithms used to compute the mathematical
   functions.  Rules for exceptional cases are specified in the
   following table.

   y                 x         atan2(y, x)
   ================= ========= ==========
   +-0               0 < x     +-0
   +-0               +0        +-0
   +-0               x < 0     +-pi
   +-0               -0        +-pi
   y, 0 < y          +-0       pi/2
   y, y < 0          +-0       -pi/2
   +-y, finite y > 0 +infinity +-0
   +-y, finite y > 0 -infinity +-pi
   +-infinity        finite x  +-pi/2
   +-infinity        +infinity +-pi/4
   +-infinity        -infinity +-3pi/4
*)
Math.atan2;
> val it = fn : real * real -> real
Math.atan2 (0.0, 1.0);
> val it = 0.0 : real
Sys.plan ();
> val it = "apply2(fnValue Math.atan2, constant(0.0), constant(1.0))" : string
List.map (fn x => (x, Math.atan2 (x, 1.0)))
  [1.0, 0.0, ~1.0, 0.5, Math.sqrt 0.5, 2.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,0.7853982),(0.0,0.0),(~1.0,~0.7853982),(0.5,0.4636476),
>    (0.70710677,0.6154797),(2.0,1.1071488),(inf,1.5707964),(~inf,~1.5707964),
>    (nan,nan)] : (real * real) list
List.map (fn (x, y) => (x, y, Math.atan2 (x, y)))
  [(0.0, 1.0), (~0.0, 1.0),
   (0.0, 0.0), (~0.0, 0.0),
   (0.0, ~1.0), (~0.0, ~1.0),
   (2.5, 0.0), (2.5, ~0.0),
   (~2.5, 0.0), (~2.5, ~0.0),
   (3.0, Real.posInf), (~3.0, Real.posInf),
   (4.0, Real.negInf), (~4.0, Real.negInf),
   (Real.posInf, 5.0), (Real.negInf, 5.0),
   (Real.posInf, Real.posInf), (Real.negInf, Real.posInf),
   (Real.posInf, Real.negInf), (Real.negInf, Real.negInf),
   (0.0, nan), (1.0, nan), (~1.0, nan), (Real.posInf, nan), (Real.negInf, nan),
   (nan, 0.0), (nan, 1.0), (nan, ~1.0), (nan, Real.posInf), (nan, Real.negInf),
   (nan, nan)];
> val it =
>   [(0.0,1.0,0.0),(~0.0,1.0,~0.0),(0.0,0.0,0.0),(~0.0,0.0,~0.0),
>    (0.0,~1.0,3.1415927),(~0.0,~1.0,~3.1415927),(2.5,0.0,1.5707964),
>    (2.5,~0.0,1.5707964),(~2.5,0.0,~1.5707964),(~2.5,~0.0,~1.5707964),
>    (3.0,inf,0.0),(~3.0,inf,~0.0),(4.0,~inf,3.1415927),(~4.0,~inf,~3.1415927),
>    (inf,5.0,1.5707964),(~inf,5.0,~1.5707964),(inf,inf,0.7853982),
>    (~inf,inf,~0.7853982),(inf,~inf,2.3561945),(~inf,~inf,~2.3561945),
>    (0.0,nan,nan),(1.0,nan,nan),(~1.0,nan,nan),(inf,nan,nan),(~inf,nan,nan),
>    (nan,0.0,nan),(nan,1.0,nan),(nan,~1.0,nan),(nan,inf,nan),(nan,~inf,nan),
>    (nan,nan,nan)] : (real * real * real) list

(* "cos x" returns the cosine of x, measured in radians. If x is an infinity,
   returns NaN. *)
Math.cos;
> val it = fn : real -> real
Math.cos 0.0;
> val it = 1.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.cos, argCode constant(0.0))" : string
List.map (fn x => (x, Math.cos x))
  [0.0, ~0.0, Math.pi, Math.pi * 0.5, ~Math.pi, Math.pi * 5.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(0.0,1.0),(~0.0,1.0),(3.1415927,~1.0),(1.5707964,~4.371139E~8),
>    (~3.1415927,~1.0),(15.707964,~1.0),(inf,nan),(~inf,nan),(nan,nan)]
>   : (real * real) list

(* "cosh x" returns the hyperbolic cosine of x, that is, (e(x) + e(-x)) / 2.
   It has the properties cosh +-0 = 1, cosh +-infinity = +-infinity. *)
Math.cosh;
> val it = fn : real -> real
Math.cosh 0.0;
> val it = 1.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.cosh, argCode constant(0.0))" : string
List.map (fn x => (x, Math.cosh x))
  [0.0, ~0.0, 1.0, Real.posInf, Real.negInf, nan];
> val it = [(0.0,1.0),(~0.0,1.0),(1.0,1.5430807),(inf,inf),(~inf,inf),(nan,nan)]
>   : (real * real) list

(* "val e : real" The base e (2.718281828...) of the natural logarithm. *)
Math.e;
> val it = 2.7182817 : real
Sys.plan ();
> val it = "constant(2.7182817)" : string

(* "exp x" returns e(x), i.e., e raised to the x(th) power. If x is
   +infinity, it returns +infinity; if x is -infinity, it returns 0. *)
Math.exp;
> val it = fn : real -> real
Math.exp 0.0;
> val it = 1.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.exp, argCode constant(0.0))" : string
List.map (fn x => (x, Math.exp x))
  [0.0, ~0.0, 1.0, ~2.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(0.0,1.0),(~0.0,1.0),(1.0,2.7182817),(~2.0,0.13533528),(inf,inf),(~inf,0.0),
>    (nan,nan)] : (real * real) list

(* "ln x" returns the natural logarithm (base e) of x. If x < 0,
   returns NaN; if x = 0, returns -infinity; if x is infinity, returns
   infinity. *)
Math.ln;
> val it = fn : real -> real
Math.ln 1.0;
> val it = 0.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.ln, argCode constant(1.0))" : string
List.map (fn x => (x, Math.ln x))
  [1.0, 2.718, Math.e, 0.0, ~0.0, ~3.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,0.0),(2.718,0.9998963),(2.7182817,0.99999994),(0.0,~inf),(~0.0,~inf),
>    (~3.0,nan),(inf,inf),(~inf,nan),(nan,nan)] : (real * real) list

(* "log10 x" returns the decimal logarithm (base 10) of x. If x < 0,
   returns NaN; if x = 0, returns -infinity; if x is infinity, returns
   infinity. *)
Math.log10;
> val it = fn : real -> real
Math.log10 1.0;
> val it = 0.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.log10, argCode constant(1.0))" : string
List.map (fn x => (x, Math.log10 x))
  [1.0, 10.0, 1000.0, 0.0, ~0.0, ~3.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,0.0),(10.0,1.0),(1000.0,3.0),(0.0,~inf),(~0.0,~inf),(~3.0,nan),
>    (inf,inf),(~inf,nan),(nan,nan)] : (real * real) list

(* "val pi : real" The constant pi (3.141592653...). *)
Math.pi;
> val it = 3.1415927 : real
Sys.plan ();
> val it = "constant(3.1415927)" : string

(* "pow (x, y)" returns x(y), i.e., x raised to the y(th) power. For
   finite x and y, this is well-defined when x > 0, or when x < 0 and
   y is integral. Rules for exceptional cases are specified below.

   x                 y                             pow(x,y)
   ================= ============================= ==========
   x, including NaN  0                             1
   |x| > 1           +infinity                     +infinity
   |x| < 1           +infinity                     +0
   |x| > 1           -infinity                     +0
   |x| < 1           -infinity                     +infinity
   +infinity         y > 0                         +infinity
   +infinity         y < 0                         +0
   -infinity         y > 0, odd integer            -infinity
   -infinity         y > 0, not odd integer        +infinity
   -infinity         y < 0, odd integer            -0
   -infinity         y < 0, not odd integer        +0
   x                 NaN                           NaN
   NaN               y <> 0                        NaN
   +-1               +-infinity                    NaN
   finite x < 0      finite non-integer y          NaN
   +-0               y < 0, odd integer            +-infinity
   +-0               finite y < 0, not odd integer +infinity
   +-0               y > 0, odd integer            +-0
   +-0               y > 0, not odd integer        +0
*)
Math.pow;
> val it = fn : real * real -> real
Math.pow (2.0, 3.0);
> val it = 8.0 : real
Math.pow (2.0, ~4.0);
> val it = 0.0625 : real
Math.pow (100.0, 0.5);
> val it = 10.0 : real
Sys.plan ();
> val it = "apply2(fnValue Math.pow, constant(100.0), constant(0.5))" : string
List.map (fn (x, y) => (x, y, Math.pow (x, y)))
  [(0.0, 0.0), (nan, 0.0),
   (2.0, Real.posInf), (~2.0, Real.posInf),
   (0.5, Real.posInf), (~0.5, Real.posInf),
   (3.0, Real.negInf), (~3.0, Real.negInf),
   (0.25, Real.negInf), (~0.25, Real.negInf),
   (Real.posInf, 0.5),
   (Real.posInf, ~0.5),
   (Real.negInf, 7.0),
   (Real.negInf, 8.0),
   (Real.negInf, ~7.0),
   (Real.negInf, ~8.0),
   (9.5, nan),
   (nan, 9.6),
   (1.0, Real.posInf), (~1.0, Real.posInf), (1.0, Real.negInf), (~1.0, Real.negInf),
   (~9.8, 2.5),
   (0.0, ~9.0), (~0.0, ~9.0),
   (0.0, ~10.0), (~0.0, ~10.0),
   (0.0, 11.0), (~0.0, 11.0),
   (0.0, 12.0), (~0.0, 12.0)];
> val it =
>   [(0.0,0.0,1.0),(nan,0.0,1.0),(2.0,inf,inf),(~2.0,inf,inf),(0.5,inf,0.0),
>    (~0.5,inf,0.0),(3.0,~inf,0.0),(~3.0,~inf,0.0),(0.25,~inf,inf),
>    (~0.25,~inf,inf),(inf,0.5,inf),(inf,~0.5,0.0),(~inf,7.0,~inf),
>    (~inf,8.0,inf),(~inf,~7.0,~0.0),(~inf,~8.0,0.0),(9.5,nan,nan),(nan,9.6,nan),
>    (1.0,inf,nan),(~1.0,inf,nan),(1.0,~inf,nan),(~1.0,~inf,nan),(~9.8,2.5,nan),
>    (0.0,~9.0,inf),(~0.0,~9.0,~inf),(0.0,~10.0,inf),(~0.0,~10.0,inf),
>    (0.0,11.0,0.0),(~0.0,11.0,~0.0),(0.0,12.0,0.0),(~0.0,12.0,0.0)]
>   : (real * real * real) list

(* "sin x" returns the sine of x, measured in radians.
   If x is an infinity, returns NaN. *)
Math.sin;
> val it = fn : real -> real
Math.sin 0.0;
> val it = 0.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.sin, argCode constant(0.0))" : string
List.map (fn x => (x, Math.sin x))
  [0.0, ~0.0, Math.pi, Math.pi * 0.5, ~Math.pi, Math.pi * 5.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(0.0,0.0),(~0.0,~0.0),(3.1415927,~8.742278E~8),(1.5707964,1.0),
>    (~3.1415927,8.742278E~8),(15.707964,~6.755325E~7),(inf,nan),(~inf,nan),
>    (nan,nan)] : (real * real) list

(* "sinh x" returns the hyperbolic sine of x, that is, (e(x) - e(-x)) / 2.
   It has the property sinh +-0 = +-0, sinh +-infinity = +-infinity. *)
Math.sinh;
> val it = fn : real -> real
Math.sinh 0.0;
> val it = 0.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.sinh, argCode constant(0.0))" : string
List.map (fn x => (x, Math.sinh x))
  [0.0, ~0.0, 1.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(0.0,0.0),(~0.0,~0.0),(1.0,1.1752012),(inf,inf),(~inf,~inf),(nan,nan)]
>   : (real * real) list

(* "sqrt x" returns the square root of x. sqrt (~0.0) = ~0.0.
   If x < 0, returns NaN. *)
Math.sqrt;
> val it = fn : real -> real
Math.sqrt 4.0;
> val it = 2.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.sqrt, argCode constant(4.0))" : string
List.map (fn x => (x, Math.sqrt x))
  [4.0, 0.0, ~0.0, ~9.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(4.0,2.0),(0.0,0.0),(~0.0,~0.0),(~9.0,nan),(inf,inf),(~inf,nan),(nan,nan)]
>   : (real * real) list

(* "tan x" returns the tangent of x, measured in radians. If x is an
   infinity, returns NaN. Produces infinities at various finite values,
   roughly corresponding to the singularities of the tangent function. *)
Math.tan;
> val it = fn : real -> real
Math.tan 0.0;
> val it = 0.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.tan, argCode constant(0.0))" : string
List.map (fn x => (x, Math.tan x))
  [0.0, ~0.0, Math.pi, Math.pi * 0.5, ~Math.pi, Math.pi * 5.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(0.0,0.0),(~0.0,~0.0),(3.1415927,8.742278E~8),(1.5707964,~2.2877332E7),
>    (~3.1415927,~8.742278E~8),(15.707964,6.755325E~7),(inf,nan),(~inf,nan),
>    (nan,nan)] : (real * real) list

(* "tanh x" returns the hyperbolic tangent of x, that is, (sinh x) / (cosh x).
   It has the properties tanh +-0 = +-0, tanh +-infinity = +-1. *)
Math.tanh;
> val it = fn : real -> real
Math.tanh 0.0;
> val it = 0.0 : real
Sys.plan ();
> val it = "apply(fnValue Math.tanh, argCode constant(0.0))" : string
List.map (fn x => (x, Math.tanh x))
  [0.0, ~0.0, 1.0, Real.posInf, Real.negInf, nan];
> val it =
>   [(0.0,0.0),(~0.0,~0.0),(1.0,0.7615942),(inf,1.0),(~inf,~1.0),(nan,nan)]
>   : (real * real) list

(* Option ------------------------------------------------------ *)
(*) val getOpt : 'a option * 'a -> 'a
Option.getOpt (SOME 1, 2);
> val it = 1 : int
Option.getOpt (NONE, 2);
> val it = 2 : int
Sys.plan ();
> val it = "apply2(fnValue Option.getOpt, constant([NONE]), constant(2))"
>   : string

(*) val isSome : 'a option -> bool
Option.isSome (SOME 1);
> val it = true : bool
Option.isSome NONE;
> val it = false : bool
Sys.plan ();
> val it = "apply(fnValue Option.isSome, argCode constant([NONE]))" : string

(*) val valOf : 'a option -> 'a
Option.valOf (SOME 1);
> val it = 1 : int
(* sml-nj gives:
    stdIn:6.1-6.18 Warning: type vars not generalized because of
       value restriction are instantiated to dummy types (X1,X2,...)
 *)
Option.valOf NONE;
> uncaught exception Option
>   raised at: stdIn:1.1-1.18
val noneInt = if true then NONE else SOME 0;
> val noneInt = NONE : int option
Sys.plan ();
> val it =
>   "apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode constant(0))), argCode constant(true))"
>   : string
Option.valOf noneInt;
> uncaught exception Option
>   raised at: stdIn:1.1-1.21
Sys.plan ();
> val it = "apply(fnValue Option.valOf, argCode constant([NONE]))" : string

(*) val filter : ('a -> bool) -> 'a -> 'a option
Option.filter (fn x => x mod 2 = 0) 1;
> val it = NONE : int option
Option.filter (fn x => x mod 2 = 0) 2;
> val it = SOME 2 : int option
Sys.plan ();
> val it =
>   "apply2(fnValue Option.filter, match(x, apply2(fnValue =, apply2(fnValue mod, get(name x), constant(2)), constant(0))), constant(2))"
>   : string

(*) val join : 'a option option -> 'a option
(*) (The function name is quoted using backticks because 'join' is a keyword.)
Option.`join` (SOME (SOME 1));
> val it = SOME 1 : int option
Option.`join` (SOME noneInt);
> val it = NONE : int option
(* sml-nj gives
  stdIn:1.2-1.18 Warning: type vars not generalized because of
     value restriction are instantiated to dummy types (X1,X2,...)
*)
Option.`join` NONE;
> val it = NONE : 'a option
Sys.plan ();
> val it = "apply(fnValue Option.join, argCode constant([NONE]))" : string

(*) val app : ('a -> unit) -> 'a option -> unit
Option.app General.ignore (SOME 1);
> val it = () : unit
Option.app General.ignore NONE;
> val it = () : unit
Sys.plan ();
> val it =
>   "apply2(fnValue Option.app, constant(General.ignore), constant([NONE]))"
>   : string

(*) val map : ('a -> 'b) -> 'a option -> 'b option
Option.map String.size (SOME "xyz");
> val it = SOME 3 : int option
Option.map String.size NONE;
> val it = NONE : int option
Sys.plan ();
> val it = "apply2(fnValue Option.map, constant(String.size), constant([NONE]))"
>   : string

(*) val mapPartial : ('a -> 'b option) -> 'a option -> 'b option
Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) (SOME "xyz");
> val it = SOME 3 : int option
Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) NONE;
> val it = NONE : int option
Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) (SOME "");
> val it = NONE : int option
Sys.plan ();
> val it =
>   "apply2(fnValue Option.mapPartial, match(s, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply(fnValue String.size, argCode get(name s)))), argCode apply2(fnValue =, get(name s), constant()))), apply(fnValue tyCon, argCode constant()))"
>   : string

(*) val compose : ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option
Option.compose;
> val it = fn : ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option
Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 1, String.size s))))
               "";
> val it = NONE : int option
Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 0, String.size s))))
               "a";
> val it = SOME 1 : int option
Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 0, String.size s))))
               "";
> val it = NONE : int option
Sys.plan ();
> val it =
>   "apply(fnCode apply2(fnValue Option.compose, constant(String.size), match(s, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply3(fnValue String.substring, get(name s), constant(0), apply(fnValue String.size, argCode get(name s))))), argCode apply2(fnValue =, get(name s), constant())))), argCode constant())"
>   : string

(*) val composePartial : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
Option.composePartial (fn i => if i = 0 then NONE else (SOME i),
                       fn s => if s = "" then NONE else SOME (String.size s))
                      "abc";
> val it = SOME 3 : int option
Option.composePartial (fn i => if i = 0 then NONE else (SOME i),
                       fn s => if s = "" then NONE else SOME (String.size s))
                      "";
> val it = NONE : int option
Sys.plan ();
> val it =
>   "apply(fnCode apply2(fnValue Option.composePartial, match(i, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode get(name i))), argCode apply2(fnValue =, get(name i), constant(0)))), match(s, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply(fnValue String.size, argCode get(name s)))), argCode apply2(fnValue =, get(name s), constant())))), argCode constant())"
>   : string

(* Char -------------------------------------------------------- *)

(* Utility function used to test the functions below. *)
fun testChar (p: char -> bool) =
  from c in String.explode "Abz0! \t\128\255"
    yield {b = p c, s = Char.toString c}
    group b compute concat over s
    order b
    yield (b, concat);
> val testChar = fn : (char -> bool) -> (bool * string) list

Char.ord;
> val it = fn : char -> int

(* [minChar] is the least character in the ordering <. *)
Char.minChar;
> val it = #"\^@" : char

(* [maxChar] is the greatest character in the ordering <. *)
Char.maxChar;
> val it = #"\255" : char

(* [maxOrd] is the greatest character code; equals ord(maxChar). *)
Char.maxOrd;
> val it = 255 : int

(* [chr i] returns the character whose code is i.  Raises Chr if
   i<0 or i>maxOrd. *)
Char.chr;
> val it = fn : int -> char
Char.chr 65;
> val it = #"A" : char
Char.chr ~1;
> uncaught exception Chr
>   raised at: stdIn:1.1-1.12
Char.chr 256;
> uncaught exception Chr
>   raised at: stdIn:1.1-1.13
Char.chr 12345678;
> uncaught exception Chr
>   raised at: stdIn:1.1-1.18

(* [ord c] returns the code of character c. *)
Char.ord;
> val it = fn : char -> int
Char.ord #"A";
> val it = 65 : int

(* [succ c] returns the character immediately following c, or raises
   Chr if c = maxChar. *)
Char.succ;
> val it = fn : char -> char
Char.succ #"A";
> val it = #"B" : char
Char.succ (chr 254);
> val it = #"\255" : char
Char.succ (chr 255);
> uncaught exception Chr
>   raised at: stdIn:1.1-1.19

(* [pred c] returns the character immediately preceding c, or raises
   Chr if c = minChar. *)
Char.pred;
> val it = fn : char -> char
Char.pred #"B";
> val it = #"A" : char
Char.pred (chr 0);
> uncaught exception Chr
>   raised at: stdIn:1.1-1.17

(* [isAscii c] returns true if c is an ASCII character (0 to 127). *)
Char.isAscii;
> val it = fn : char -> bool
Char.isAscii #"A";
> val it = true : bool
testChar Char.isAscii;
> val it = [(false,"\\128\\255"),(true,"Abz0! \\t")] : (bool * string) list

(* [isLower c] returns true if c is a lowercase letter (a to z). *)
Char.isLower;
> val it = fn : char -> bool
Char.isLower #"A";
> val it = false : bool
testChar Char.isLower;
> val it = [(false,"A0! \\t\\128\\255"),(true,"bz")] : (bool * string) list

(* [isUpper c] returns true if c is a uppercase letter (A to Z). *)
Char.isUpper;
> val it = fn : char -> bool
Char.isUpper #"A";
> val it = true : bool
testChar Char.isUpper;
> val it = [(false,"bz0! \\t\\128\\255"),(true,"A")] : (bool * string) list

(* [isAlpha c] returns true if c is a letter (lowercase or uppercase). *)
Char.isAlpha;
> val it = fn : char -> bool
Char.isAlpha #"A";
> val it = true : bool
testChar Char.isAlpha;
> val it = [(false,"0! \\t\\128\\255"),(true,"Abz")] : (bool * string) list

(* [isDigit c] returns true if c is a decimal digit (0 to 9). *)
Char.isDigit;
> val it = fn : char -> bool
Char.isDigit #"A";
> val it = false : bool
testChar Char.isDigit;
> val it = [(false,"Abz! \\t\\128\\255"),(true,"0")] : (bool * string) list

(* [isHexDigit c] returns true if c is a hexadecimal digit (0 to 9 or
   a to f or A to F). *)
Char.isHexDigit;
> val it = fn : char -> bool
Char.isHexDigit #"A";
> val it = true : bool
testChar Char.isHexDigit;
> val it = [(false,"z! \\t\\128\\255"),(true,"Ab0")] : (bool * string) list

(* [isAlphaNum c] returns true if c is alphanumeric (a letter or a
   decimal digit). *)
Char.isAlphaNum;
> val it = fn : char -> bool
Char.isAlphaNum #"A";
> val it = true : bool
testChar Char.isAlphaNum;
> val it = [(false,"! \\t\\128\\255"),(true,"Abz0")] : (bool * string) list

(* [isPrint c] returns true if c is a printable character (space or visible) *)
Char.isPrint;
> val it = fn : char -> bool
Char.isPrint #"A";
> val it = true : bool
testChar Char.isPrint;
> val it = [(false,"\\t\\128\\255"),(true,"Abz0! ")] : (bool * string) list

(* [isSpace c] returns true if c is a whitespace character (blank, newline,
   tab, vertical tab, new page). *)
Char.isSpace;
> val it = fn : char -> bool
Char.isSpace #"A";
> val it = false : bool
testChar Char.isSpace;
> val it = [(false,"Abz0!\\128\\255"),(true," \\t")] : (bool * string) list

(* [isGraph c] returns true if c is a graphical character, that is,
   it is printable and not a whitespace character. *)
Char.isGraph;
> val it = fn : char -> bool
Char.isGraph #"A";
> val it = true : bool
testChar Char.isGraph;
> val it = [(false," \\t\\128\\255"),(true,"Abz0!")] : (bool * string) list

(* [isPunct c] returns true if c is a punctuation character, that is,
   graphical but not alphanumeric. *)
Char.isPunct;
> val it = fn : char -> bool
Char.isPunct #"A";
> val it = false : bool
testChar Char.isPunct;
> val it = [(false,"Abz0 \\t\\128\\255"),(true,"!")] : (bool * string) list

(* [isCntrl c] returns true if c is a control character, that is, if
   not (isPrint c). *)
Char.isCntrl;
> val it = fn : char -> bool
testChar Char.isCntrl;
> val it = [(false,"Abz0! \\128\\255"),(true,"\\t")] : (bool * string) list

(* [isAscii c] returns true if 0 <= ord c <= 127. *)
Char.isAscii;
> val it = fn : char -> bool
testChar Char.isAscii;
> val it = [(false,"\\128\\255"),(true,"Abz0! \\t")] : (bool * string) list

(* [toLower c] returns the lowercase letter corresponding to c,
   if c is a letter (a to z or A to Z); otherwise returns c. *)
Char.toLower;
> val it = fn : char -> char
Char.toLower #"A";
> val it = #"a" : char
Char.toLower #"a";
> val it = #"a" : char
Char.toLower #" ";
> val it = #" " : char
Char.toLower #"\^@";
> val it = #"\^@" : char

(* [toUpper c] returns the uppercase letter corresponding to c,
   if c is a letter (a to z or A to Z); otherwise returns c. *)
Char.toUpper;
> val it = fn : char -> char
Char.toUpper #"A";
> val it = #"A" : char
Char.toUpper #"a";
> val it = #"A" : char
Char.toUpper #" ";
> val it = #" " : char
Char.toUpper #"\^@";
> val it = #"\^@" : char

(* [contains s c] returns true if character c occurs in the string s;
   false otherwise.  The function, when applied to s, builds a table
   and returns a function which uses table lookup to decide whether a
   given character is in the string or not.  Hence it is relatively
   expensive to compute `val p = contains s` but very fast to compute
   `p(c)` for any given character. *)
Char.contains;
> val it = fn : string -> char -> bool
val p = Char.contains "abc";
> val p = fn : char -> bool
p #"a";
> val it = true : bool
p #"z";
> val it = false : bool
p #"\128";
> val it = false : bool
testChar p;
> val it = [(false,"Az0! \\t\\128\\255"),(true,"b")] : (bool * string) list

(* [notContains s c] returns true if character c does not occur in the
   string s; false otherwise.  Works by construction of a lookup table
   in the same way as the above function. *)
Char.notContains;
> val it = fn : string -> char -> bool
val p = Char.notContains "abc";
> val p = fn : char -> bool
p #"a";
> val it = false : bool
p #"z";
> val it = true : bool
p #"\128";
> val it = true : bool
testChar p;
> val it = [(false,"b"),(true,"Az0! \\t\\128\\255")] : (bool * string) list

(* [fromString s] attempts to scan a character or ML escape sequence
   from the string s.  Does not skip leading whitespace.  For
   instance, fromString "\\065" equals #"A". *)
Char.fromString;
> val it = fn : string -> char option
Char.fromString "\\065";
> val it = SOME #"A" : char option
Char.fromString "a";
> val it = SOME #"a" : char option
Char.fromString "\^@";
> val it = SOME #"\^@" : char option
Char.fromString "\t";
> val it = SOME #"\t" : char option
Char.fromString "\\t";
> val it = SOME #"\t" : char option
Char.fromString "\009";
> val it = SOME #"\t" : char option
Char.fromString "\\009";
> val it = SOME #"\t" : char option

(* [toString c] returns a string consisting of the character c, if c
      is printable, else an ML escape sequence corresponding to c.  A
      printable character is mapped to a one-character string; bell,
      backspace, tab, newline, vertical tab, form feed, and carriage
      return are mapped to the two-character strings "\\a", "\\b", "\\t",
      "\\n", "\\v", "\\f", and "\\r"; other characters with code less
      than 32 are mapped to three-character strings of the form "\\^Z",
      and characters with codes 127 through 255 are mapped to
      four-character strings of the form "\\ddd", where ddd are three decimal
      digits representing the character code.  For instance,
                toString #"A"      equals "A"
                toString #"\\"     equals "\\\\"
                toString #"\""     equals "\\\""
                toString (chr   0) equals "\\^@"
                toString (chr   1) equals "\\^A"
                toString (chr   6) equals "\\^F"
                toString (chr   7) equals "\\a"
                toString (chr   8) equals "\\b"
                toString (chr   9) equals "\\t"
                toString (chr  10) equals "\\n"
                toString (chr  11) equals "\\v"
                toString (chr  12) equals "\\f"
                toString (chr  13) equals "\\r"
                toString (chr  14) equals "\\^N"
                toString (chr 127) equals "\\127"
                toString (chr 128) equals "\\128" *)
Char.toString;
> val it = fn : char -> string
Char.toString #"A";
> val it = "A" : string
Char.toString #"\\";
> val it = "\\\\" : string
Char.toString #"\"";
> val it = "\\\"" : string
Char.toString (chr 0);
> val it = "\\^@" : string
Char.toString (chr 1);
> val it = "\\^A" : string
Char.toString (chr 2);
> val it = "\\^B" : string
Char.toString (chr 6);
> val it = "\\^F" : string
Char.toString (chr 7);
> val it = "\\a" : string
Char.toString (chr 8);
> val it = "\\b" : string
Char.toString (chr 9);
> val it = "\\t" : string
Char.toString (chr 10);
> val it = "\\n" : string
Char.toString (chr 11);
> val it = "\\v" : string
Char.toString (chr 12);
> val it = "\\f" : string
Char.toString (chr 13);
> val it = "\\r" : string
Char.toString (chr 14);
> val it = "\\^N" : string
Char.toString (chr 127);
> val it = "\\127" : string
Char.toString (chr 128);
> val it = "\\128" : string
Char.toString (chr 129);
> val it = "\\129" : string
Char.toString (chr 255);
> val it = "\\255" : string

chr 0;
> val it = #"\^@" : char
chr 1;
> val it = #"\^A" : char
chr 2;
> val it = #"\^B" : char
chr 6;
> val it = #"\^F" : char
chr 7;
> val it = #"\a" : char
chr 8;
> val it = #"\b" : char
chr 9;
> val it = #"\t" : char
chr 10;
> val it = #"\n" : char
chr 11;
> val it = #"\v" : char
chr 12;
> val it = #"\f" : char
chr 13;
> val it = #"\r" : char
chr 14;
> val it = #"\^N" : char
chr 48;
> val it = #"0" : char
chr 65;
> val it = #"A" : char
chr 96;
> val it = #"`" : char
chr 97;
> val it = #"a" : char
chr 127;
> val it = #"\127" : char
chr 128;
> val it = #"\128" : char
chr 255;
> val it = #"\255" : char

(* [fromCString s] attempts to scan a character or C escape sequence
   from the string s.  Does not skip leading whitespace.  For
   instance, fromString "\\065" equals #"A". *)
Char.fromString;
> val it = fn : string -> char option

(* [toCString c] returns a string consisting of the character c, if c
   is printable, else an C escape sequence corresponding to c.  A
   printable character is mapped to a one-character string; bell,
   backspace, tab, newline, vertical tab, form feed, and carriage
   return are mapped to the two-character strings "\\a", "\\b", "\\t",
   "\\n", "\\v", "\\f", and "\\r"; other characters are mapped to
   four-character strings of the form "\\ooo", where ooo are three
   octal digits representing the character code.  For instance,
             toString #"A"      equals "A"
             toString #"A"      equals "A"
             toString #"\\"     equals "\\\\"
             toString #"\""     equals "\\\""
             toString (chr   0) equals "\\000"
             toString (chr   1) equals "\\001"
             toString (chr   6) equals "\\006"
             toString (chr   7) equals "\\a"
             toString (chr   8) equals "\\b"
             toString (chr   9) equals "\\t"
             toString (chr  10) equals "\\n"
             toString (chr  11) equals "\\v"
             toString (chr  12) equals "\\f"
             toString (chr  13) equals "\\r"
             toString (chr  14) equals "\\016"
             toString (chr 127) equals "\\177"
             toString (chr 128) equals "\\200" *)
Char.toCString;
> val it = fn : char -> string

(* [<]
   [<=]
   [>]
   [>=] compares character codes.  For instance, c1 < c2 returns true
   if ord(c1) < ord(c2), and similarly for <=, >, >=. *)

Char.`op <`;
> val it = fn : char * char -> bool
#"A" < #"B";
> val it = true : bool
#"a" < #"A";
> val it = false : bool

Char.`op <=`;
> val it = fn : char * char -> bool
#"A" <= #"B";
> val it = true : bool

Char.`op >`;
> val it = fn : char * char -> bool
#"A" > #"B";
> val it = false : bool

Char.`op >=`;
> val it = fn : char * char -> bool
#"A" >= #"B";
> val it = false : bool

(* TODO: Standard ML accepts the following:
    Char.<;
    Char.<=;
    Char.>;
    Char.>=;
*)

(* [compare(c1, c2)] returns LESS, EQUAL, or GREATER, according as c1 is
   precedes, equals, or follows c2 in the ordering Char.< . *)
Char.compare;
> val it = fn : char * char -> order
Char.compare (#"a", #"a");
> val it = EQUAL : order
Char.compare (#"d", #"a");
> val it = GREATER : order
Char.compare (#"D", #"a");
> val it = LESS : order
Char.compare (#"a", #"D");
> val it = GREATER : order

(* Int --------------------------------------------------------- *)
Int.abs;
> val it = fn : int -> int
Int.abs 5;
> val it = 5 : int
Int.abs ~3;
> val it = 3 : int
Int.compare;
> val it = fn : int * int -> order
Int.compare (4, 3);
> val it = GREATER : order
Int.`div`;
> val it = fn : int * int -> int
Int.`div` (14, 3);
> val it = 4 : int
Int.`div` (~14, 3);
> val it = ~5 : int
Int.`div` (14, ~3);
> val it = ~5 : int
Int.`div` (~14, ~3);
> val it = 4 : int
Int.`div` (0, ~3);
> val it = 0 : int
Int.fromInt;
> val it = fn : int -> int
Int.fromInt 3;
> val it = 3 : int
Int.fromLarge;
> val it = fn : int -> int
Int.fromLarge 3;
> val it = 3 : int
Int.fromString;
> val it = fn : string -> int option
Int.fromString "~345";
> val it = SOME ~345 : int option
Int.max;
> val it = fn : int * int -> int
Int.max (4, 3);
> val it = 4 : int
Int.maxInt;
> val it = SOME 2147483647 : int option
Int.min;
> val it = fn : int * int -> int
Int.min (4, 3);
> val it = 3 : int
Int.`mod`;
> val it = fn : int * int -> int
Int.`mod` (14, 3);
> val it = 2 : int
Int.`mod` (~14, 3);
> val it = 1 : int
Int.`mod` (14, ~3);
> val it = ~1 : int
Int.`mod` (~14, ~3);
> val it = ~2 : int
Int.`mod` (0, ~3);
> val it = 0 : int
Int.quot;
> val it = fn : int * int -> int
Int.quot (14, 3);
> val it = 4 : int
Int.quot (~14, 3);
> val it = ~4 : int
Int.quot (14, ~3);
> val it = ~4 : int
Int.quot (~14, ~3);
> val it = 4 : int
Int.quot (0, ~3);
> val it = 0 : int
Int.precision;
> val it = SOME 32 : int option
Int.rem;
> val it = fn : int * int -> int
Int.rem (14, 3);
> val it = 2 : int
Int.rem (~14, 3);
> val it = ~2 : int
Int.rem (14, ~3);
> val it = 2 : int
Int.rem (~14, ~3);
> val it = ~2 : int
Int.rem (0, ~3);
> val it = 0 : int
Int.sameSign;
> val it = fn : int * int -> bool
Int.sameSign (3, ~2);
> val it = false : bool
Int.sameSign (0, ~2);
> val it = false : bool
Int.sameSign (2, 345);
> val it = true : bool
Int.sameSign (0, 0);
> val it = true : bool
Int.sign;
> val it = fn : int -> int
Int.sign ~3;
> val it = ~1 : int
Int.toInt;
> val it = fn : int -> int
Int.toInt 3;
> val it = 3 : int
Int.toLarge;
> val it = fn : int -> int
Int.toLarge 3;
> val it = 3 : int
Int.toString;
> val it = fn : int -> string
Int.toString ~345;
> val it = "~345" : string

(* Real -------------------------------------------------------- *)

(*) val radix : int
Real.radix;
> val it = 2 : int

(*) val precision : int
Real.precision;
> val it = 24 : int

(*) val maxFinite : real
Real.maxFinite;
> val it = 3.4028235E38 : real

(*) val minPos : real
Real.minPos;
> val it = 1.4E~45 : real

(*) val minNormalPos : real
Real.minNormalPos;
> val it = 1.1754944E~38 : real

(*) val posInf : real
Real.posInf;
> val it = inf : real

(*) val negInf : real
Real.negInf;
> val it = ~inf : real

(* "r1 + r2" and "r1 - r2" are the sum and difference of r1 and r2. If one
   argument is finite and the other infinite, the result is infinite with the
   correct sign, e.g., 5 - (-infinity) = infinity. We also have infinity +
   infinity = infinity and (-infinity) + (-infinity) = (-infinity). Any other
   combination of two infinities produces NaN. *)
1.0 + ~3.5;
> val it = ~2.5 : real

1.0 + Real.posInf;
> val it = inf : real
Real.posInf + 2.5;
> val it = inf : real
Real.posInf - Real.posInf;
> val it = nan : real
Real.posInf + Real.posInf;
> val it = inf : real
Real.posInf + Real.negInf;
> val it = nan : real
Real.negInf + Real.negInf;
> val it = ~inf : real
5.0 - Real.negInf;
> val it = inf : real

(* "r1 * r2" is the product of r1 and r2. The product of zero and an infinity
   produces NaN. Otherwise, if one argument is infinite, the result is infinite
   with the correct sign, e.g., -5 * (-infinity) = infinity, infinity *
   (-infinity) = -infinity. *)
0.0 * Real.posInf;
> val it = nan : real
0.0 * Real.negInf;
> val it = nan : real
~0.0 * Real.negInf;
> val it = nan : real
0.5 * 34.6;
> val it = 17.3 : real
Real.posInf * 2.0;
> val it = inf : real
Real.posInf * Real.negInf;
> val it = ~inf : real
Real.negInf * Real.negInf;
> val it = inf : real

(* "r1 / r2" denotes the quotient of r1 and r2. We have 0 / 0 = NaN and
   +-infinity / +-infinity = NaN. Dividing a finite, non-zero number by a zero,
   or an infinity by a finite number produces an infinity with the correct sign.
   (Note that zeros are signed.) A finite number divided by an infinity is 0
   with the correct sign. *)
0.0 / 0.0;
> val it = nan : real
Real.posInf / Real.negInf;
> val it = nan : real
1.5 / Real.posInf;
> val it = 0.0 : real
1.5 / Real.negInf;
> val it = ~0.0 : real
~1.5 / Real.negInf;
> val it = 0.0 : real
~0.0 + ~0.0;
> val it = ~0.0 : real
~0.0 + 0.0;
> val it = 0.0 : real
0.0 + ~0.0;
> val it = 0.0 : real

(* "rem (x, y)" returns the remainder x - n * y, where n = trunc (x / y). The
    result has the same sign as x and has absolute value less than the absolute
    value of y. If x is an infinity or y is 0, rem returns NaN. If y is an
    infinity, rem returns x. *)
Real.rem;
> val it = fn : real * real -> real
Real.rem (13.0, 5.0);
> val it = 3.0 : real
Real.rem (~13.0, 5.0);
> val it = ~3.0 : real
Real.rem (13.0, ~5.0);
> val it = 3.0 : real
Real.rem (~13.0, ~5.0);
> val it = ~3.0 : real
Real.rem (13.0, 0.0);
> val it = nan : real
Real.rem (13.0, ~0.0);
> val it = nan : real
(*) In the following, Morel returns 13.0 per the spec; sml-nj returns nan.
Real.rem (13.0, Real.negInf);
> val it = 13.0 : real
(*) In the following, Morel returns 13.0 per the spec; sml-nj returns nan.
Real.rem (13.0, Real.posInf);
> val it = 13.0 : real
Sys.plan ();
> val it = "apply2(fnValue Real.rem, constant(13.0), constant(Infinity))"
>   : string

(* "*+ (a, b, c)" and "*- (a, b, c)" return a * b + c and a * b - c,
   respectively. Their behaviors on infinities follow from the behaviors derived
   from addition, subtraction, and multiplication. *)
(*) TODO Real.*+ (2.0, 3.0, 7.0);
(*) TODO val it = 13.0 : real
(*) TODO Real.*- (2.0, 3.0, 7.0);
(*) TODO val it = ~1.0 : real

(* "~ r" produces the negation of r.
   ~ (+-infinity) = -+infinity. *)
~ 2.0;
> val it = ~2.0 : real
~ ~3.5;
> val it = 3.5 : real
~ Real.posInf;
> val it = ~inf : real
~ Real.negInf;
> val it = inf : real
~ nan;
> val it = nan : real

(* "abs r" returns the absolute value |r| of r.
    abs (+-0.0) = +0.0;
    abs (+-infinity) = +infinity;
    abs (+-NaN) = +NaN *)
Real.abs;
> val it = fn : real -> real
Real.abs ~5.5;
> val it = 5.5 : real
Real.abs Real.posInf;
> val it = inf : real
Real.abs Real.negInf;
> val it = inf : real
Real.abs nan;
> val it = nan : real
Sys.plan ();
> val it = "apply(fnValue Real.abs, argCode constant(NaN))" : string

(* val min : real * real -> real
   val max : real * real -> real
   These return the smaller (respectively, larger) of the arguments. If exactly
   one argument is NaN, they return the other argument. If both arguments are
   NaN, they return NaN. *)
Real.min;
> val it = fn : real * real -> real
Real.min (3.5, 4.5);
> val it = 3.5 : real
Real.min (3.5, ~4.5);
> val it = ~4.5 : real
Real.min (nan, 4.5);
> val it = 4.5 : real
Real.min (~5.5, nan);
> val it = ~5.5 : real
Real.min (Real.posInf, 4.5);
> val it = 4.5 : real
Real.min (Real.negInf, 4.5);
> val it = ~inf : real
Sys.plan ();
> val it = "apply2(fnValue Real.min, constant(-Infinity), constant(4.5))"
>   : string

Real.max;
> val it = fn : real * real -> real
Real.max (3.5, 4.5);
> val it = 4.5 : real
Real.max (3.5, ~4.5);
> val it = 3.5 : real
Real.max (nan, 4.5);
> val it = 4.5 : real
Real.max (Real.posInf, 4.5);
> val it = inf : real
Real.max (Real.negInf, 4.5);
> val it = 4.5 : real
Sys.plan ();
> val it = "apply2(fnValue Real.max, constant(-Infinity), constant(4.5))"
>   : string

(* "sign r" returns ~1 if r is negative, 0 if r is zero, or 1 if r is positive.
    An infinity returns its sign; a zero returns 0 regardless of its sign.
    It raises Domain on NaN. *)
Real.sign;
> val it = fn : real -> int
Real.sign 2.0;
> val it = 1 : int
Real.sign ~3.0;
> val it = ~1 : int
Real.sign 0.0;
> val it = 0 : int
Real.sign ~0.0;
> val it = 0 : int
Real.sign Real.posInf;
> val it = 1 : int
Real.sign Real.negInf;
> val it = ~1 : int
Real.sign nan;
> uncaught exception Domain
>   raised at: stdIn:1.1-1.14
Sys.plan ();
> val it = "apply(fnValue Real.sign, argCode constant(NaN))" : string

(* "signBit r" returns true if and only if the sign of r (infinities, zeros,
   and NaN, included) is negative. *)
Real.signBit;
> val it = fn : real -> bool
Real.signBit 2.0;
> val it = false : bool
Real.signBit ~3.5;
> val it = true : bool
Real.signBit 0.0;
> val it = false : bool
Real.signBit ~0.0;
> val it = true : bool
Real.signBit Real.posInf;
> val it = false : bool
Real.signBit Real.negInf;
> val it = true : bool
(*) In SMLNJ and Mlton, nan is negative; we do the same
Real.signBit nan;
> val it = true : bool
(*) In SMLNJ and Mlton, ~nan is positive; we do the same
Real.signBit (~nan);
> val it = false : bool
Sys.plan ();
> val it =
>   "apply(fnValue Real.signBit, argCode apply(fnValue ~, argCode constant(NaN)))"
>   : string
Real.signBit (~(~nan));
> val it = true : bool

(* "sameSign (r1, r2)" returns true if and only if signBit r1 equals
   signBit r2. *)
Real.sameSign;
> val it = fn : real * real -> bool
Real.sameSign (2.0, 3.5);
> val it = true : bool
Real.sameSign (~2.0, Real.negInf);
> val it = true : bool
Real.sameSign (2.0, nan);
> val it = false : bool
Real.sameSign (~2.0, nan);
> val it = true : bool
Real.sameSign (nan, nan);
> val it = true : bool
Sys.plan ();
> val it = "apply2(fnValue Real.sameSign, constant(NaN), constant(NaN))"
>   : string

(* "copySign (x, y)" returns x with the sign of y, even if y is NaN. *)
Real.copySign;
> val it = fn : real * real -> real
Real.copySign (2.0, Real.posInf);
> val it = 2.0 : real
Real.copySign (2.0, Real.negInf);
> val it = ~2.0 : real
Real.copySign (2.0, nan);
> val it = ~2.0 : real
Real.copySign (~3.5, ~nan);
> val it = 3.5 : real
Real.copySign (~3.5, nan);
> val it = ~3.5 : real
Real.copySign (2.0, ~0.0);
> val it = ~2.0 : real
Sys.plan ();
> val it = "apply2(fnValue Real.copySign, constant(2.0), constant(-0.0))"
>   : string

(* "val compare : real * real -> order" returns LESS, EQUAL, or GREATER
   according to whether its first argument is less than, equal to, or
   greater than the second. It raises IEEEReal.Unordered on unordered
   arguments. *)
Real.compare;
> val it = fn : real * real -> order
Real.compare (2.0, 2.0);
> val it = EQUAL : order
Real.compare (~0.0, 0.0);
> val it = EQUAL : order
Real.compare (~5.0, Real.posInf);
> val it = LESS : order
Real.compare (~5.0, Real.negInf);
> val it = GREATER : order
Real.compare (Real.negInf, Real.negInf);
> val it = EQUAL : order
Real.compare (Real.negInf, nan);
> uncaught exception Unordered
>   raised at: stdIn:1.1-1.32
Real.compare (nan, nan);
> uncaught exception Unordered
>   raised at: stdIn:1.1-1.24
Sys.plan ();
> val it = "apply2(fnValue Real.compare, constant(NaN), constant(NaN))" : string

(* "val compareReal : real * real -> IEEEReal.real_order" behaves similarly to
   "Real.compare" except that the values it returns have the extended type
   IEEEReal.real_order and it returns IEEEReal.UNORDERED on unordered
   arguments. *)
(*) TODO Real.compareReal (2.0, 2.0);
(*) TODO val it = EQUAL : IEEEReal.real_order
(*) TODO Real.compareReal (~0.0, 0.0);
(*) TODO val it = EQUAL : IEEEReal.real_order
(*) TODO Real.compareReal (~5.0, Real.posInf);
(*) TODO val it = LESS : IEEEReal.real_order
(*) TODO Real.compareReal (~5.0, Real.negInf);
(*) TODO val it = GREATER : IEEEReal.real_order
(*) TODO Real.compareReal (Real.negInf, Real.negInf);
(*) TODO val it = EQUAL : IEEEReal.real_order
(*) TODO Real.compareReal (Real.negInf, nan);
(*) TODO val it = UNORDERED : IEEEReal.real_order
(*) TODO Real.compareReal (nan, nan);
(*) TODO val it = UNORDERED : IEEEReal.real_order
(*) TODO Real.compareReal (~nan, nan);
(*) TODO val it = UNORDERED : IEEEReal.real_order
(*) TODO Real.compareReal (0.0, ~nan);
(*) TODO val it = UNORDERED : IEEEReal.real_order

(* val < : real * real -> bool
   val <= : real * real -> bool
   val > : real * real -> bool
   val >= : real * real -> bool
   These return true if the corresponding relation holds between the two reals.
  Note that these operators return false on unordered arguments, i.e., if
  either argument is NaN, so that the usual reversal of comparison under
  negation does not hold, e.g., a < b is not the same as not (a >= b). *)
3.0 < 3.0;
> val it = false : bool
3.0 < 5.0;
> val it = true : bool
3.0 < nan;
> val it = false : bool
nan < 5.0;
> val it = false : bool
3.0 < Real.posInf;
> val it = true : bool
3.0 < Real.negInf;
> val it = false : bool
Real.posInf < Real.posInf;
> val it = false : bool

3.0 <= 3.0;
> val it = true : bool
3.0 <= 5.0;
> val it = true : bool
3.0 <= nan;
> val it = false : bool
nan <= 5.0;
> val it = false : bool
3.0 <= Real.posInf;
> val it = true : bool
3.0 <= Real.negInf;
> val it = false : bool
Real.posInf <= Real.posInf;
> val it = true : bool

3.0 > 3.0;
> val it = false : bool
3.0 > 5.0;
> val it = false : bool
3.0 > nan;
> val it = false : bool
nan > 5.0;
> val it = false : bool
3.0 > Real.posInf;
> val it = false : bool
3.0 > Real.negInf;
> val it = true : bool
Real.posInf > Real.posInf;
> val it = false : bool

3.0 >= 3.0;
> val it = true : bool
3.0 >= 5.0;
> val it = false : bool
3.0 >= nan;
> val it = false : bool
nan >= 5.0;
> val it = false : bool
3.0 >= Real.posInf;
> val it = false : bool
3.0 >= Real.negInf;
> val it = true : bool
Real.posInf >= Real.posInf;
> val it = true : bool

(* "== (x, y)" eturns true if and only if neither y nor x is NaN, and y and x
   are equal, ignoring signs on zeros. This is equivalent to the IEEE =
   operator. *)
(*) TODO

(* "!= (x, y)" is equivalent to not o op == and the IEEE ?<> operator. *)
(*) TODO

(* "val ?= : real * real -> bool" returns true if either argument is NaN or if
   the arguments are bitwise equal, ignoring signs on zeros. It is equivalent
   to the IEEE ?= operator. *)
(*) TODO

(* "unordered (x, y)" returns true if x and y are unordered, i.e., at least one
   of x and y is NaN. *)
Real.unordered;
> val it = fn : real * real -> bool
Real.unordered (1.0, 1.0);
> val it = false : bool
Real.unordered (~1.0, 1.0);
> val it = false : bool
Real.unordered (Real.negInf, Real.posInf);
> val it = false : bool
Real.unordered (nan, 1.0);
> val it = true : bool
Real.unordered (0.0, nan);
> val it = true : bool

(* "isFinite x" returns true if x is neither NaN nor an infinity. *)
Real.isFinite;
> val it = fn : real -> bool
Real.isFinite 0.0;
> val it = true : bool
Real.isFinite ~0.0;
> val it = true : bool
Real.isFinite 1.5;
> val it = true : bool
Real.isFinite Real.posInf;
> val it = false : bool
Real.isFinite Real.negInf;
> val it = false : bool
Real.isFinite nan;
> val it = false : bool

(* "isNan x" returns true if x is NaN. *)
Real.isNan;
> val it = fn : real -> bool
Real.isNan 0.0;
> val it = false : bool
Real.isNan ~0.0;
> val it = false : bool
Real.isNan 1.5;
> val it = false : bool
Real.isNan Real.posInf;
> val it = false : bool
Real.isNan Real.negInf;
> val it = false : bool
Real.isNan Real.minNormalPos;
> val it = false : bool
Real.isNan Real.minPos;
> val it = false : bool
Real.isNan nan;
> val it = true : bool
Real.isNan (~nan);
> val it = true : bool
Real.isNan (~(~nan));
> val it = true : bool
Real.isNan (nan + 3.0);
> val it = true : bool

(* "isNormal x" returns true if x is normal, i.e., neither zero, subnormal,
   infinite nor NaN. *)
Real.isNormal;
> val it = fn : real -> bool
Real.isNormal 0.0;
> val it = false : bool
Real.isNormal ~0.0;
> val it = false : bool
Real.isNormal 1.5;
> val it = true : bool
Real.isNormal ~0.1;
> val it = true : bool
Real.isNormal Real.posInf;
> val it = false : bool
Real.isNormal Real.negInf;
> val it = false : bool
Real.isNormal Real.minNormalPos;
> val it = true : bool
Real.isNormal Real.minPos;
> val it = false : bool
Real.isNormal nan;
> val it = false : bool

(* "class x" returns the IEEEReal.float_class to which x belongs. *)
(*) TODO

(* "toManExp r" returns {man, exp}, where man and exp are the mantissa and
   exponent of r, respectively. Specifically, we have the relation
     r = man * radix(exp)
   where 1.0 <= man * radix < radix. This function is comparable to frexp in
   the C library. If r is +-0, man is +-0 and exp is +0. If r is +-infinity,
   man is +-infinity and exp is unspecified. If r is NaN, man is NaN and exp
   is unspecified. *)
Real.toManExp;
> val it = fn : real -> {exp:int, man:real}
Real.toManExp 0.0;
> val it = {exp=~126,man=0.0} : {exp:int, man:real}
Sys.plan ();
> val it = "apply(fnValue Real.toManExp, argCode constant(0.0))" : string
Real.toManExp ~0.0;
> val it = {exp=~126,man=~0.0} : {exp:int, man:real}
Real.toManExp 0.5;
> val it = {exp=0,man=0.5} : {exp:int, man:real}
Real.toManExp 1.0;
> val it = {exp=1,man=0.5} : {exp:int, man:real}
Real.toManExp 2.0;
> val it = {exp=2,man=0.5} : {exp:int, man:real}
Real.toManExp 1.25;
> val it = {exp=1,man=0.625} : {exp:int, man:real}
Real.toManExp 2.5;
> val it = {exp=2,man=0.625} : {exp:int, man:real}
Real.toManExp ~2.5;
> val it = {exp=2,man=~0.625} : {exp:int, man:real}
Real.toManExp nan;
> val it = {exp=129,man=nan} : {exp:int, man:real}
Real.toManExp Real.posInf;
> val it = {exp=129,man=inf} : {exp:int, man:real}
Real.toManExp Real.negInf;
> val it = {exp=129,man=~inf} : {exp:int, man:real}
Real.toManExp Real.maxFinite;
> val it = {exp=128,man=0.99999994} : {exp:int, man:real}
Real.toManExp (~Real.maxFinite);
> val it = {exp=128,man=~0.99999994} : {exp:int, man:real}
Real.toManExp Real.minNormalPos;
> val it = {exp=~125,man=0.5} : {exp:int, man:real}
Real.toManExp (~Real.minNormalPos);
> val it = {exp=~125,man=~0.5} : {exp:int, man:real}
Real.toManExp (Real.minNormalPos / 2.0);
> val it = {exp=~126,man=0.5} : {exp:int, man:real}
Real.toManExp (Real.minNormalPos / 4.0);
> val it = {exp=~126,man=0.25} : {exp:int, man:real}
Real.toManExp Real.minPos;
> val it = {exp=~126,man=1.1920929E~7} : {exp:int, man:real}
Real.minNormalPos / Real.minPos;
> val it = 8388608.0 : real
List.map (fn x => (x, Real.toManExp x, Real.fromManExp (Real.toManExp x)))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, 2.0,
   0.0000123456, 0.00000123456, 0.000000123456, ~0.00000123456,
   Real.minPos, Real.minNormalPos, Real.maxFinite, ~Real.maxFinite,
   Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,{exp=1,man=0.5},1.0),(0.0,{exp=~126,man=0.0},0.0),
>    (~0.0,{exp=~126,man=~0.0},~0.0),(~1.0,{exp=1,man=~0.5},~1.0),
>    (0.5,{exp=0,man=0.5},0.5),(2.0,{exp=2,man=0.5},2.0),
>    (1.23456E~5,{exp=~16,man=0.80908126},1.23456E~5),
>    (1.23456E~6,{exp=~19,man=0.647265},1.23456E~6),
>    (1.23456E~7,{exp=~22,man=0.517812},1.23456E~7),
>    (~1.23456E~6,{exp=~19,man=~0.647265},~1.23456E~6),
>    (1.4E~45,{exp=~126,man=1.1920929E~7},1.4E~45),
>    (1.1754944E~38,{exp=~125,man=0.5},1.1754944E~38),
>    (3.4028235E38,{exp=128,man=0.99999994},3.4028235E38),
>    (~3.4028235E38,{exp=128,man=~0.99999994},~3.4028235E38),
>    (inf,{exp=129,man=inf},inf),(~inf,{exp=129,man=~inf},~inf),
>    (nan,{exp=129,man=nan},nan)] : (real * {exp:int, man:real} * real) list

(* "fromManExp {man, exp}" returns man * radix(exp). This function is comparable
   to ldexp in the C library. Note that, even if man is a non-zero, finite real
   value, the result of fromManExp can be zero or infinity because of underflows
   and overflows. If man is +-0, the result is +-0. If man is +-infinity, the
   result is +-infinity. If man is NaN, the result is NaN. *)
Real.fromManExp;
> val it = fn : {exp:int, man:real} -> real
Real.fromManExp {man = 1.0, exp = 0};
> val it = 1.0 : real
Sys.plan ();
> val it = "apply2(fnValue Real.fromManExp, constant(0), constant(1.0))"
>   : string
Real.fromManExp {man = ~1.0, exp = 0};
> val it = ~1.0 : real
Real.fromManExp {man = 1.0, exp = 2};
> val it = 4.0 : real
Real.fromManExp {man = 1.0, exp = ~3};
> val it = 0.125 : real
List.map (fn x => (x, Real.fromManExp (Real.toManExp x)))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, 2.0,
   0.0000123456, 0.00000123456, 0.000000123456, ~0.00000123456,
   Real.minPos, Real.minNormalPos, Real.maxFinite, ~Real.maxFinite,
   Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,1.0),(0.0,0.0),(~0.0,~0.0),(~1.0,~1.0),(0.5,0.5),(2.0,2.0),
>    (1.23456E~5,1.23456E~5),(1.23456E~6,1.23456E~6),(1.23456E~7,1.23456E~7),
>    (~1.23456E~6,~1.23456E~6),(1.4E~45,1.4E~45),(1.1754944E~38,1.1754944E~38),
>    (3.4028235E38,3.4028235E38),(~3.4028235E38,~3.4028235E38),(inf,inf),
>    (~inf,~inf),(nan,nan)] : (real * real) list

(* "split r" returns {whole, frac}, where frac and whole are the fractional and
   integral parts of r, respectively. Specifically, whole is integral,
   |frac| < 1.0, whole and frac have the same sign as r, and r = whole + frac.
   This function is comparable to modf in the C library. If r is +-infinity,
   whole is +-infinity and frac is +-0. If r is NaN, both whole and frac are
   NaN. *)
Real.split;
> val it = fn : real -> {frac:real, whole:real}
Real.split 2.0;
> val it = {frac=0.0,whole=2.0} : {frac:real, whole:real}
Real.split 0.0;
> val it = {frac=0.0,whole=0.0} : {frac:real, whole:real}
Real.split ~0.0;
> val it = {frac=~0.0,whole=0.0} : {frac:real, whole:real}
Real.split 2.75;
> val it = {frac=0.75,whole=2.0} : {frac:real, whole:real}
Real.split ~12.25;
> val it = {frac=~0.25,whole=~12.0} : {frac:real, whole:real}
Real.split Real.posInf;
> val it = {frac=0.0,whole=inf} : {frac:real, whole:real}
Real.split Real.negInf;
> val it = {frac=~0.0,whole=~inf} : {frac:real, whole:real}
Real.split nan;
> val it = {frac=nan,whole=nan} : {frac:real, whole:real}
Sys.plan ();
> val it = "apply(fnValue Real.split, argCode constant(NaN))" : string

(* "realMod r" returns the fractional part of r. "realMod" is equivalent to
   "#frac o split". *)
Real.realMod;
> val it = fn : real -> real
Real.realMod 2.0;
> val it = 0.0 : real
Real.realMod 0.0;
> val it = 0.0 : real
Real.realMod ~0.0;
> val it = ~0.0 : real
Real.realMod 2.75;
> val it = 0.75 : real
Real.realMod ~12.25;
> val it = ~0.25 : real
Real.realMod Real.posInf;
> val it = 0.0 : real
Real.realMod Real.negInf;
> val it = ~0.0 : real
Real.realMod nan;
> val it = nan : real
Sys.plan ();
> val it = "apply(fnValue Real.realMod, argCode constant(NaN))" : string

(* "nextAfter (r, t)" returns the next representable real after r in the
   direction of t. Thus, if t is less than r, nextAfter returns the largest
   representable floating-point number less than r. If r = t then it returns
   r. If either argument is NaN, this returns NaN. If r is +-infinity, it
   returns +-infinity. *)
(*) TODO

(* "checkFloat x" raises Overflow if x is an infinity, and raises Div if x is
   NaN. Otherwise, it returns its argument. This can be used to synthesize
   trapping arithmetic from the non-trapping operations given here. Note,
   however, that infinities can be converted to NaNs by some operations, so
   that if accurate exceptions are required, checks must be done after each
   operation. *)
Real.checkFloat;
> val it = fn : real -> real
Real.checkFloat 0.0;
> val it = 0.0 : real
Real.checkFloat ~0.0;
> val it = ~0.0 : real
Real.checkFloat 1.5;
> val it = 1.5 : real
Real.checkFloat Real.posInf;
> uncaught exception Overflow
>   raised at: stdIn:1.1-1.28
Real.checkFloat Real.negInf;
> uncaught exception Overflow
>   raised at: stdIn:1.1-1.28
Real.checkFloat Real.minNormalPos;
> val it = 1.1754944E~38 : real
Real.checkFloat Real.minPos;
> val it = 1.4E~45 : real
Real.checkFloat nan;
> uncaught exception Div
>   raised at: stdIn:1.1-1.20

(* "realFloor r", "realCeil r", "realTrunc r", "realRound r" convert real values
   to integer-valued reals. realFloor produces floor(r), the largest integer not
   larger than r. realCeil produces ceil(r), the smallest integer not less than r.
   realTrunc rounds r towards zero, and realRound rounds to the integer-valued
   real value that is nearest to r. If r is NaN or an infinity, these functions
   return r. *)
Real.realFloor;
> val it = fn : real -> real
Real.realCeil;
> val it = fn : real -> real
Real.realTrunc;
> val it = fn : real -> real
Real.realRound;
> val it = fn : real -> real
fun f x = (Real.realFloor x, Real.realCeil x, Real.realTrunc x, Real.realRound x);
> val f = fn : real -> real * real * real * real
f 0.0;
> val it = (0.0,0.0,0.0,0.0) : real * real * real * real
f ~2.0;
> val it = (~2.0,~2.0,~2.0,~2.0) : real * real * real * real
f ~1.75;
> val it = (~2.0,~1.0,~1.0,~2.0) : real * real * real * real
f ~2.25;
> val it = (~3.0,~2.0,~2.0,~2.0) : real * real * real * real
f ~2.5;
> val it = (~3.0,~2.0,~2.0,~2.0) : real * real * real * real
f ~3.5;
> val it = (~4.0,~3.0,~3.0,~4.0) : real * real * real * real
f Real.negInf;
> val it = (~inf,~inf,nan,~inf) : real * real * real * real
f Real.posInf;
> val it = (inf,inf,nan,inf) : real * real * real * real
f nan;
> val it = (nan,nan,nan,nan) : real * real * real * real

(* "floor r", "ceil r", "trunc r", "round r" convert reals to integers.
   floor produces floor(r), the largest int not larger than r.
   ceil produces ceil(r), the smallest int not less than r.
   trunc rounds r towards zero.
   round yields the integer nearest to r. In the case of a tie, it rounds to the
   nearest even integer.

   They raise Overflow if the resulting value cannot be represented as an int,
   for example, on infinity. They raise Domain on NaN arguments.

   These are respectively equivalent to:
     toInt IEEEReal.TO_NEGINF r
     toInt IEEEReal.TO_POSINF r
     toInt IEEEReal.TO_ZERO r
     toInt IEEEReal.TO_NEAREST r *)
Real.floor;
> val it = fn : real -> int
Real.ceil;
> val it = fn : real -> int
Real.trunc;
> val it = fn : real -> int
Real.round;
> val it = fn : real -> int
fun f x = (Real.floor x, Real.ceil x, Real.trunc x, Real.round x);
> val f = fn : real -> int * int * int * int
f 0.0;
> val it = (0,0,0,0) : int * int * int * int
f ~2.0;
> val it = (~2,~2,~2,~2) : int * int * int * int
f ~1.75;
> val it = (~2,~2,~1,~2) : int * int * int * int
f ~2.25;
> val it = (~2,~2,~2,~2) : int * int * int * int
f ~2.5;
> val it = (~2,~3,~2,~2) : int * int * int * int
f ~3.5;
> val it = (~3,~4,~3,~3) : int * int * int * int
f Real.negInf;
> val it = (~2147483648,~2147483647,~2147483648,~2147483648)
>   : int * int * int * int
f Real.posInf;
> val it = (~2147483648,2147483647,2147483647,2147483647)
>   : int * int * int * int
f nan;
> val it = (0,0,0,0) : int * int * int * int

(* "toInt mode x", "toLargeInt mode x" convert the argument x to an integral
   type using the specified rounding mode. They raise Overflow if the result
   is not representable, in particular, if x is an infinity. They raise
   Domain if the input real is NaN. *)
(*) TODO

(* "fromInt i", "fromLargeInt i" convert the integer i to a real value. If the
   absolute value of i is larger than maxFinite, then the appropriate infinity
   is returned. If i cannot be exactly represented as a real value, then the
   current rounding mode is used to determine the resulting value. The top-level
   function real is an alias for Real.fromInt. *)
Real.fromInt;
> val it = fn : int -> real
Real.fromInt 1;
> val it = 1.0 : real
Real.fromInt ~2;
> val it = ~2.0 : real
Sys.plan ();
> val it = "apply(fnValue Real.fromInt, argCode constant(-2))" : string

(*) real is a synonym for Real.fromInt
real;
> val it = fn : int -> real
real ~2;
> val it = ~2.0 : real
Sys.plan ();
> val it = "apply(fnValue Real.fromInt, argCode constant(-2))" : string

(*  "fromString s" scans a `real` value from a string. Returns `SOME(r)` if a
    `real` value can be scanned from a prefix of `s`, ignoring any initial
    whitespace; otherwise, it returns `NONE`. This function is equivalent to
    `StringCvt.scanString scan`. *)
Real.fromString;
> val it = fn : string -> real option
Real.fromString "~0.0";
> val it = SOME ~0.0 : real option
Sys.plan ();
> val it = "apply(fnValue Real.fromString, argCode constant(~0.0))" : string
Real.fromString "~23.45e~06";
> val it = SOME ~2.345E~5 : real option
(*) sml-nj allows both '-' and '~', both 'E' and 'e', and 0s after 'E'.
Real.fromString "-1.5";
> val it = SOME ~1.5 : real option
Real.fromString "~1.5";
> val it = SOME ~1.5 : real option
Real.fromString "-1.5e-9";
> val it = SOME ~1.5E~9 : real option
Real.fromString "-1.5e-09";
> val it = SOME ~1.5E~9 : real option
Real.fromString "-1.5E-9";
> val it = SOME ~1.5E~9 : real option
Real.fromString "-1.5E~9";
> val it = SOME ~1.5E~9 : real option
Real.fromString "-1.5E~09";
> val it = SOME ~1.5E~9 : real option
Real.fromString "-1.5e~09";
> val it = SOME ~1.5E~9 : real option
(*) In sml-nj, ".", ".e", ".e-", "e5", ".e7" are invalid
Real.fromString ".";
> val it = NONE : real option
Real.fromString ".x";
> val it = NONE : real option
Real.fromString ".e";
> val it = NONE : real option
Real.fromString ".e~";
> val it = NONE : real option
Real.fromString "e5";
> val it = NONE : real option
Real.fromString ".e7";
> val it = NONE : real option
(*) Letters and whitespace at the end, and whitespace at the start, are ignored
Real.fromString "1.5x";
> val it = SOME 1.5 : real option
Real.fromString " 1.5 x ";
> val it = SOME 1.5 : real option
Real.fromString "1.5e";
> val it = SOME 1.5 : real option
Real.fromString "1.5e~";
> val it = SOME 1.5 : real option
Real.fromString "1.5e~0";
> val it = SOME 1.5 : real option
Real.fromString "1.5e2";
> val it = SOME 150.0 : real option
Real.fromString "1.5e2e";
> val it = SOME 150.0 : real option
Real.fromString "1.5e2e3";
> val it = SOME 150.0 : real option
Real.fromString "2e3.4";
> val it = SOME 2000.0 : real option
Real.fromString "  2e3.4";
> val it = SOME 2000.0 : real option
Real.fromString "2.x";
> val it = SOME 2.0 : real option
(*) fromString cannot parse "inf", "nan" etc.
Real.fromString "inf";
> val it = NONE : real option
Real.fromString "~inf";
> val it = NONE : real option
Real.fromString "-inf";
> val it = NONE : real option
Real.fromString "nan";
> val it = NONE : real option

List.map (fn x => (x, Real.fromString (Real.toString x)))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, 2.0,
   0.0000123456, 0.00000123456, 0.000000123456, ~0.00000123456,
   Real.minPos, Real.minNormalPos, Real.maxFinite, ~Real.maxFinite,
   Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,SOME 1.0),(0.0,SOME 0.0),(~0.0,SOME ~0.0),(~1.0,SOME ~1.0),
>    (0.5,SOME 0.5),(2.0,SOME 2.0),(1.23456E~5,SOME 1.23456E~5),
>    (1.23456E~6,SOME 1.23456E~6),(1.23456E~7,SOME 1.23456E~7),
>    (~1.23456E~6,SOME ~1.23456E~6),(1.4E~45,SOME 1.4E~45),
>    (1.1754944E~38,SOME 1.1754944E~38),(3.4028235E38,SOME 3.4028235E38),
>    (~3.4028235E38,SOME ~3.4028235E38),(inf,NONE),(~inf,NONE),(nan,NONE)]
>   : (real * real option) list

(* "toLarge r", "fromLarge r" convert between values of type real and type
   LargeReal.real. If r is too small or too large to be represented as a real,
   fromLarge will convert it to a zero or an infinity.

   Note that SMLNJ diverges from the the spec. The spec:
      Real.toLarge : real -> LargeReal.real
      Real.fromLarge : LargeReal.real -> real
   SMLNJ:
      Real.toLarge : real -> real
      Real.fromLarge : IEEEReal.rounding_mode -> real -> real *)
(*) TODO

(* "fmt spec r", "toString r" convert reals into strings. The conversion
   provided by the function fmt is parameterized by spec, which has the
   following forms and interpretations.

   SCI arg
     Scientific notation:
       [~]?[0-9].[0-9]+?E[0-9]+
     where there is always one digit before the decimal point, nonzero if the
     number is nonzero. arg specifies the number of digits to appear after the
     decimal point, with 6 the default if arg is NONE. If arg is SOME(0), no
     fractional digits and no decimal point are printed.
   FIX arg
     Fixed-point notation:
       [~]?[0-9]+.[0-9]+?
     arg specifies the number of digits to appear after the decimal point, with
     6 the default if arg is NONE. If arg is SOME(0), no fractional digits and
     no decimal point are printed.
   GEN arg
     Adaptive notation: the notation used is either scientific or fixed-point
     depending on the value converted. arg specifies the maximum number of
     significant digits used, with 12 the default if arg is NONE.
   EXACT
     Exact decimal notation: refer to IEEEReal.toString for a complete
     description of this format.
   In all cases, positive and negative infinities are converted to "inf" and
   "~inf", respectively, and NaN values are converted to the string "nan".

   Refer to StringCvt.realfmt for more details concerning these formats,
   especially the adaptive format GEN.

   fmt raises Size if spec is an invalid precision, i.e., if spec is
     SCI (SOME i) with i < 0
     FIX (SOME i) with i < 0
     GEN (SOME i) with i < 1
   The exception should be raised when fmt spec is evaluated.

  The fmt function allows the user precise control as to the form of the
  resulting string. Note, therefore, that it is possible for fmt to produce
  a result that is not a valid SML string representation of a real value.

  The value returned by toString is equivalent to:
    (fmt (StringCvt.GEN NONE) r)
 *)
(*) TODO Real.fmt

Real.toString;
> val it = fn : real -> string
Real.toString 0.0;
> val it = "0.0" : string
Sys.plan ();
> val it = "apply(fnValue Real.toString, argCode constant(0.0))" : string
Real.toString ~0.0;
> val it = "~0.0" : string
Real.toString 0.01;
> val it = "0.01" : string
Real.toString Real.minPos;
> val it = "1.4E~45" : string
Real.toString Real.minNormalPos;
> val it = "1.1754944E~38" : string
Real.toString 1234567890123.45;
> val it = "1.234568E12" : string
Real.toString 123456789012.3;
> val it = "1.2345679E11" : string
Real.toString 12345678901.23;
> val it = "1.2345679E10" : string
Real.toString 123456789.0123;
> val it = "1.2345679E8" : string
(*) We return '1.23456E~6' but sml-nj returns '1.23456E~06'.
Real.toString 0.00000123456;
> val it = "1.23456E~6" : string
Real.toString 0.0000123456;
> val it = "1.23456E~5" : string
Real.toString 0.000123456;
> val it = "1.23456E~4" : string
Real.toString 0.0001234567;
> val it = "1.234567E~4" : string
Real.toString 0.00012345678;
> val it = "1.2345678E~4" : string
Real.toString 0.0000123;
> val it = "1.23E~5" : string
Real.toString ~0.000065432;
> val it = "~6.5432E~5" : string
Real.toString nan;
> val it = "nan" : string
Real.toString Real.negInf;
> val it = "~inf" : string
Real.toString Real.posInf;
> val it = "inf" : string
List.map (fn x => (x, Real.toString x))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, 2.0,
   0.0000123456, 0.00000123456, 0.000000123456, ~0.00000123456,
   Real.minPos, Real.minNormalPos, Real.maxFinite, ~Real.maxFinite,
   Real.posInf, Real.negInf, nan];
> val it =
>   [(1.0,"1.0"),(0.0,"0.0"),(~0.0,"~0.0"),(~1.0,"~1.0"),(0.5,"0.5"),(2.0,"2.0"),
>    (1.23456E~5,"1.23456E~5"),(1.23456E~6,"1.23456E~6"),
>    (1.23456E~7,"1.23456E~7"),(~1.23456E~6,"~1.23456E~6"),(1.4E~45,"1.4E~45"),
>    (1.1754944E~38,"1.1754944E~38"),(3.4028235E38,"3.4028235E38"),
>    (~3.4028235E38,"~3.4028235E38"),(inf,"inf"),(~inf,"~inf"),(nan,"nan")]
>   : (real * string) list

(* "scan getc strm", "fromString s" scan a real value from character source. The
   first version reads from ARG/strm/ using reader getc, ignoring initial
   whitespace. It returns SOME(r,rest) if successful, where r is the scanned
   real value and rest is the unused portion of the character stream strm.
   Values of too large a magnitude are represented as infinities; values of too
   small a magnitude are represented as zeros. The second version returns
   SOME(r) if a real value can be scanned from a prefix of s, ignoring any
   initial whitespace; otherwise, it returns NONE. This function is equivalent
   to StringCvt.scanString scan.

   The functions accept real numbers with the following format:
     [+~-]?([0-9]+.[0-9]+? | .[0-9]+)(e | E)[+~-]?[0-9]+?

   It also accepts the following string representations of non-finite values:
     [+~-]?(inf | infinity | nan)
   where the alphabetic characters are case-insensitive. *)
(*) TODO

(* "toDecimal r", "fromDecimal d" convert between real values and decimal
   approximations. Decimal approximations are to be converted using the
   IEEEReal.TO_NEAREST rounding mode. toDecimal should produce only as many
   digits as are necessary for fromDecimal to convert back to the same number.
   In particular, for any normal or subnormal real value r, we have the bit-wise
   equality:
     fromDecimal (toDecimal r) = r.

   For toDecimal, when the r is not normal or subnormal, then the exp field is
   set to 0 and the digits field is the empty list. In all cases, the sign and
   class field capture the sign and class of r.

  For fromDecimal, if class is ZERO or INF, the resulting real is the
  appropriate signed zero or infinity. If class is NAN, a signed NaN is
  generated. If class is NORMAL or SUBNORMAL, the sign, digits and exp fields
  are used to produce a real number whose value is

    s * 0.d(1)d(2)...d(n) 10(exp)

  where digits = [d(1), d(2), ..., d(n)] and where s is -1 if sign is true and 1
  otherwise. Note that the conversion itself should ignore the class field, so
  that the resulting value might have class NORMAL, SUBNORMAL, ZERO, or INF. For
  example, if digits is empty or a list of all 0's, the result should be a
  signed zero. More generally, very large or small magnitudes are converted to
  infinities or zeros.

  If the argument to fromDecimal does not have a valid format, i.e., if the
  digits field contains integers outside the range [0,9], it returns NONE.

  Implementation note: Algorithms for accurately and efficiently converting
  between binary and decimal real representations are readily available, e.g.,
  see the technical report by Gay[CITE]. *)
(*) TODO

(* Relational -------------------------------------------------- *)

Relational.count (bag [1, 2, 3]);
> val it = 3 : int
Relational.count (bag []);
> val it = 0 : int
Relational.count (bag [false]);
> val it = 1 : int
Sys.plan ();
> val it =
>   "apply(fnValue Relational.count, argCode apply(fnValue Bag.fromList, argCode tuple(constant(false))))"
>   : string

Relational.nonEmpty [1, 2, 3];
> val it = true : bool
Relational.nonEmpty [];
> val it = false : bool
Relational.nonEmpty [false];
> val it = true : bool
Sys.plan ();
> val it = "apply(fnValue Relational.nonEmpty, argCode tuple(constant(false)))"
>   : string

Relational.empty [1, 2, 3];
> val it = false : bool
Relational.empty [];
> val it = true : bool
Relational.empty [false];
> val it = false : bool
Sys.plan ();
> val it = "apply(fnValue Relational.empty, argCode tuple(constant(false)))"
>   : string

val emps = [
  {empno=7839, ename="KING", mgr=0},
  {empno=7566, ename="JONES", mgr=7839},
  {empno=7698, ename="BLAKE", mgr=7839},
  {empno=7782, ename="CLARK", mgr=7839},
  {empno=7788, ename="SCOTT", mgr=7566},
  {empno=7902, ename="FORD", mgr=7566},
  {empno=7499, ename="ALLEN", mgr=7698},
  {empno=7521, ename="WARD", mgr=7698},
  {empno=7654, ename="MARTIN", mgr=7698},
  {empno=7844, ename="TURNER", mgr=7698},
  {empno=7900, ename="JAMES", mgr=7698},
  {empno=7934, ename="MILLER", mgr=7782},
  {empno=7876, ename="ADAMS", mgr=7788},
  {empno=7369, ename="SMITH", mgr=7902}];
> val emps =
>   [{empno=7839,ename="KING",mgr=0},{empno=7566,ename="JONES",mgr=7839},
>    {empno=7698,ename="BLAKE",mgr=7839},{empno=7782,ename="CLARK",mgr=7839},
>    {empno=7788,ename="SCOTT",mgr=7566},{empno=7902,ename="FORD",mgr=7566},
>    {empno=7499,ename="ALLEN",mgr=7698},{empno=7521,ename="WARD",mgr=7698},
>    {empno=7654,ename="MARTIN",mgr=7698},{empno=7844,ename="TURNER",mgr=7698},
>    {empno=7900,ename="JAMES",mgr=7698},{empno=7934,ename="MILLER",mgr=7782},
>    {empno=7876,ename="ADAMS",mgr=7788},{empno=7369,ename="SMITH",mgr=7902}]
>   : {empno:int, ename:string, mgr:int} list
Relational.iterate
  (from e in emps where e.mgr = 0)
  fn (oldList, newList) =>
      (from d in newList,
          e in emps
      where e.mgr = d.empno
      yield e);
> val it =
>   [{empno=7839,ename="KING",mgr=0},{empno=7566,ename="JONES",mgr=7839},
>    {empno=7698,ename="BLAKE",mgr=7839},{empno=7782,ename="CLARK",mgr=7839},
>    {empno=7788,ename="SCOTT",mgr=7566},{empno=7902,ename="FORD",mgr=7566},
>    {empno=7499,ename="ALLEN",mgr=7698},{empno=7521,ename="WARD",mgr=7698},
>    {empno=7654,ename="MARTIN",mgr=7698},{empno=7844,ename="TURNER",mgr=7698},
>    {empno=7900,ename="JAMES",mgr=7698},{empno=7934,ename="MILLER",mgr=7782},
>    {empno=7876,ename="ADAMS",mgr=7788},{empno=7369,ename="SMITH",mgr=7902}]
>   : {empno:int, ename:string, mgr:int} list
Sys.plan ();
> val it =
>   "apply2(fnValue Relational.iterate, from(sink join(pat e_1, exp constant([[7839, KING, 0], [7566, JONES, 7839], [7698, BLAKE, 7839], [7782, CLARK, 7839], [7788, SCOTT, 7566], [7902, FORD, 7566], [7499, ALLEN, 7698], [7521, WARD, 7698], [7654, MARTIN, 7698], [7844, TURNER, 7698], [7900, JAMES, 7698], [7934, MILLER, 7782], [7876, ADAMS, 7788], [7369, SMITH, 7902]]), sink where(condition apply2(fnValue =, apply(fnValue nth:2, argCode get(name e)), constant(0)), sink collect(get(name e))))), match(v, apply(fnCode match((oldList, newList), from(sink join(pat d, exp get(name newList), sink join(pat e, exp constant([[7839, KING, 0], [7566, JONES, 7839], [7698, BLAKE, 7839], [7782, CLARK, 7839], [7788, SCOTT, 7566], [7902, FORD, 7566], [7499, ALLEN, 7698], [7521, WARD, 7698], [7654, MARTIN, 7698], [7844, TURNER, 7698], [7900, JAMES, 7698], [7934, MILLER, 7782], [7876, ADAMS, 7788], [7369, SMITH, 7902]]), sink where(condition apply2(fnValue =, apply(fnValue nth:2, argCode get(name e)), apply(fnValue nth:0, argCode get(name d))), sink collect(get(name e))))))), argCode get(name v))))"
>   : string

Relational.sum [1, 2, 3];
> val it = 6 : int
Sys.plan ();
> val it =
>   "apply(fnValue Relational.sum$int, argCode tuple(constant(1), constant(2), constant(3)))"
>   : string
Relational.sum [1.0, 2.5, 3.5];
> val it = 7.0 : real
Sys.plan ();
> val it =
>   "apply(fnValue Relational.sum$real, argCode tuple(constant(1.0), constant(2.5), constant(3.5)))"
>   : string

Relational.max [1, 2, 3];
> val it = 3 : int
Relational.max [1.0, 2.5, 3.5];
> val it = 3.5 : real
Relational.max ["a", "bc", "ab"];
> val it = "bc" : string
Relational.max [false, true];
> val it = true : bool
Sys.plan ();
> val it =
>   "apply(fnValue Relational.max, argCode tuple(constant(false), constant(true)))"
>   : string

Relational.min [1, 2, 3];
> val it = 1 : int
Relational.min [1.0, 2.5, 3.5];
> val it = 1.0 : real
Relational.min ["a", "bc", "ab"];
> val it = "a" : string
Relational.min [false, true];
> val it = false : bool
Sys.plan ();
> val it =
>   "apply(fnValue Relational.min, argCode tuple(constant(false), constant(true)))"
>   : string

Relational.only [2];
> val it = 2 : int
Relational.only [1, 2, 3];
> uncaught exception Size
>   raised at: stdIn:1.1-1.26
Relational.only [];
> uncaught exception Empty
>   raised at: stdIn:1.1-1.19
Sys.plan ();
> val it = "apply(fnValue Relational.only, argCode tuple)" : string

List.concat [[1, 2], [3], [], [4, 2, 5]];
> val it = [1,2,3,4,2,5] : int list
List.concat [[], []];
> val it = [] : 'a list
Sys.plan ();
> val it = "apply(fnValue List.concat, argCode tuple(tuple, tuple))" : string

List.`except` [[1, 2], [2], [3], []];
> val it = [1] : int list
List.`except` [[], []];
> val it = [] : 'a list
List.`except` [["a"], ["a"]];
> val it = [] : string list
List.`except` [["a", "b", "c", "a"], ["a"]];
> val it = ["b","c"] : string list
List.`except` [["a", "b", "c", "a"], ["c", "b", "c"]];
> val it = ["a","a"] : string list
List.`except` [["a", "b"], ["a", "c"], ["a"]];
> val it = ["b"] : string list
Sys.plan ();
> val it =
>   "apply(fnValue List.except, argCode tuple(tuple(constant(a), constant(b)), tuple(constant(a), constant(c)), tuple(constant(a))))"
>   : string

List.`intersect` [[1, 2], [2], [0, 2, 4]];
> val it = [2] : int list
List.`intersect` [[1, 2], []];
> val it = [] : int list
List.`intersect` [[], [1, 2]];
> val it = [] : int list
List.`intersect` [["a", "b", "a"], ["b", "a"]];
> val it = ["a","b","a"] : string list
List.`intersect` [[(1, 2), (2, 3)], [(2, 4), (1, 2)]];
> val it = [(1,2)] : (int * int) list
List.`except` [List.`intersect` [[1, 2, 3], [2, 3, 4]], [1, 3, 5]];
> val it = [2] : int list
List.`except` [[1, 2, 3], List.`intersect` [[1, 3, 5], [2, 3, 4]]];
> val it = [1,2] : int list
Sys.plan ();
> val it =
>   "apply(fnValue List.except, argCode tuple(tuple(constant(1), constant(2), constant(3)), apply(fnValue List.intersect, argCode tuple(tuple(constant(1), constant(3), constant(5)), tuple(constant(2), constant(3), constant(4))))))"
>   : string

1 elem [1, 2, 3];
> val it = true : bool
1 elem [2, 3, 4];
> val it = false : bool
1 elem [];
> val it = false : bool
[] elem [[0], [1, 2]];
> val it = false : bool
[] elem [[0], [], [1, 2]];
> val it = true : bool
[1, 2] elem [[0], [], [1, 2]];
> val it = true : bool
bag [] elem [bag [0], bag [1, 2]];
> val it = false : bool
bag [] elem [bag [0], bag [], bag [1, 2]];
> val it = true : bool
bag [1, 2] elem [bag [0], bag [], bag [1, 2]];
> val it = true : bool
(1, 2) elem [(0, 1), (1, 2)];
> val it = true : bool
(1, 2) elem [(0, 1), (2, 3)];
> val it = false : bool
Sys.plan ();
> val it =
>   "apply2(fnValue elem, tuple(constant(1), constant(2)), tuple(tuple(constant(0), constant(1)), tuple(constant(2), constant(3))))"
>   : string

(* Repeat the above tests for the bag version of elem. *)
1 elem bag [1, 2, 3];
> val it = true : bool
1 elem bag [2, 3, 4];
> val it = false : bool
1 elem bag [];
> val it = false : bool
[] elem bag [[0], [1, 2]];
> val it = false : bool
[] elem bag [[0], [], [1, 2]];
> val it = true : bool
bag [] elem bag [bag [0], bag [], bag [1, 2]];
> val it = true : bool
(1, 2) elem bag [(0, 1), (1, 2)];
> val it = true : bool
(1, 2) elem bag [(0, 1), (2, 3)];
> val it = false : bool

1 notelem [1, 2, 3];
> val it = false : bool
1 notelem [2, 3, 4];
> val it = true : bool
1 notelem [];
> val it = true : bool
[] notelem [[0], [1, 2]];
> val it = true : bool
[] notelem [[0], [], [1, 2]];
> val it = false : bool
(1, 2) notelem [(0, 1), (1, 2)];
> val it = false : bool
(1, 2) notelem [(0, 1), (2, 3)];
> val it = true : bool
Sys.plan ();
> val it =
>   "apply2(fnValue notelem, tuple(constant(1), constant(2)), tuple(tuple(constant(0), constant(1)), tuple(constant(2), constant(3))))"
>   : string

(* Repeat the above tests for the bag version of notelem. *)
1 notelem bag [1, 2, 3];
> val it = false : bool
1 notelem bag [2, 3, 4];
> val it = true : bool
1 notelem bag [];
> val it = true : bool
[] notelem bag [[0], [1, 2]];
> val it = true : bool
[] notelem bag [[0], [], [1, 2]];
> val it = false : bool
(1, 2) notelem bag [(0, 1), (1, 2)];
> val it = false : bool
(1, 2) notelem bag [(0, 1), (2, 3)];
> val it = true : bool

(*) The "compare" function.
Relational.compare;
> val it = fn : 'a * 'a -> order
Relational.compare (1, 2);
> val it = LESS : order
Relational.compare (2, 1);
> val it = GREATER : order
Relational.compare (false, true);
> val it = LESS : order
(*) Tuples are compared lexicographically.
Relational.compare (("a", 2), ("b", 0));
> val it = LESS : order
Relational.compare (("a", 2), ("a", 0));
> val it = GREATER : order
Relational.compare (("a", 2), ("a", 2));
> val it = EQUAL : order
(*) Lists are compared lexicographically.
Relational.compare ([1, 2, 3, 1], [1, 2, 4, 1]);
> val it = LESS : order
Relational.compare ([1, 2, 3], [1, 2, 4, 1]);
> val it = LESS : order
Relational.compare ([1, 2, 3, 1], [1, 2, 4]);
> val it = LESS : order
Relational.compare ([1, 2, 3, 1], []);
> val it = GREATER : order
(*) Bags are compared lexicographically (their elements taken in arbitrary order).
Relational.compare (bag [1, 2, 3, 1], bag [1, 2, 4, 1]);
> val it = LESS : order
Relational.compare (bag [1, 2, 3], bag [1, 2, 4, 1]);
> val it = LESS : order
Relational.compare (bag [1, 2, 3, 1], bag [1, 2, 4]);
> val it = LESS : order
Relational.compare (bag [1, 2, 3, 1], bag []);
> val it = GREATER : order
(*) Records are compared lexicographically by their fields in alphabetical order.
Relational.compare ({a=1, b=2.0}, {a=2, b=1.0});
> val it = LESS : order
Relational.compare ({c=1, b=2.0}, {c=2, b=1.0});
> val it = GREATER : order
(*) Option compares with NONE less than any value.
Relational.compare (SOME 1, NONE);
> val it = GREATER : order
Relational.compare (SOME 1, SOME "a");
> 0.0-0.0 Error: Cannot deduce type: conflict: int vs string
>   raised at: 0.0-0.0
Relational.compare (SOME ~1, NONE);
> val it = GREATER : order
Relational.compare (NONE, NONE);
> val it = EQUAL : order
Relational.compare (SOME (SOME 1), SOME (SOME 2));
> val it = LESS : order
(*) "Order" compares with LESS < EQUAL < GREATER.
Relational.compare (LESS, EQUAL);
> val it = LESS : order
Relational.compare (EQUAL, GREATER);
> val it = LESS : order
(*) "Descending" reverses the order of comparison.
Relational.compare (DESC 1, DESC 2);
> val it = GREATER : order
Relational.compare (DESC (1, "b"), DESC (1, "a"));
> val it = LESS : order
Relational.compare ((1, DESC "b"), (1, DESC "a"));
> val it = LESS : order
(*) Lists compare lexicographically; shorter list is less.
Relational.compare ([], [1, 2]);
> val it = LESS : order
Relational.compare ([SOME 1, NONE], [SOME 1, SOME 2, SOME 3, NONE]);
> val it = LESS : order

(*) Use Relational.compare as comparator for List.collate and Vector.collate.
List.collate Relational.compare ([1,2,3],[1,2,4]);
> val it = LESS : order
List.collate Relational.compare ([SOME 1, SOME 0, SOME 2], [SOME 1, NONE, SOME 2]);
> val it = GREATER : order
List.collate Relational.compare ([NONE, SOME 1], [NONE, SOME 1, NONE]);
> val it = LESS : order
Vector.collate Relational.compare (Vector.fromList [1,2,3], Vector.fromList [1,2,4]);
> val it = LESS : order

(* Sys --------------------------------------------------------- *)

(*) val env : unit -> string list
Sys.env;
> val it = fn : unit -> (string * string) list
Sys.env ();
> val it =
>   [
>    ("Bag",
>     "{all:forall 'a. ('a -> bool) -> 'a bag -> bool, app:forall 'a. ('a -> unit) -> 'a bag -> unit, at:forall 'a. 'a bag * 'a bag -> 'a bag, concat:forall 'a. 'a bag list -> 'a bag, drop:forall 'a. 'a bag * int -> 'a bag, exists:forall 'a. ('a -> bool) -> 'a bag -> bool, filter:forall 'a. ('a -> bool) -> 'a bag -> 'a bag, find:forall 'a. ('a -> bool) -> 'a bag -> 'a option, fold:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a bag -> 'b, fromList:forall 'a. 'a list -> 'a bag, getItem:forall 'a. 'a bag -> ('a * 'a bag) option, hd:forall 'a. 'a bag -> 'a, length:forall 'a. 'a bag -> int, map:forall 'a 'b. ('a -> 'b) -> 'a bag -> 'b bag, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a bag -> 'b bag, nil:forall 'a. 'a bag, nth:forall 'a. 'a bag * int -> 'a, null:forall 'a. 'a bag -> bool, `op @`:forall 'a. 'a bag * 'a bag -> 'a bag, partition:forall 'a. ('a -> bool) -> 'a bag -> 'a bag * 'a bag, tabulate:forall 'a. int * (int -> 'a) -> 'a bag, take:forall 'a. 'a bag * int -> 'a bag, tl:forall 'a. 'a bag -> 'a bag, toList:forall 'a. 'a bag -> 'a list}"),
>    ("Char",
>     "{chr:int -> char, compare:char * char -> order, contains:string -> char -> bool, fromCString:string -> char option, fromString:string -> char option, isAlpha:char -> bool, isAlphaNum:char -> bool, isAscii:char -> bool, isCntrl:char -> bool, isDigit:char -> bool, isGraph:char -> bool, isHexDigit:char -> bool, isLower:char -> bool, isPrint:char -> bool, isPunct:char -> bool, isSpace:char -> bool, isUpper:char -> bool, maxChar:char, maxOrd:int, minChar:char, notContains:string -> char -> bool, `op <`:char * char -> bool, `op <=`:char * char -> bool, `op >`:char * char -> bool, `op >=`:char * char -> bool, ord:char -> int, pred:char -> char, succ:char -> char, toCString:char -> string, toLower:char -> char, toString:char -> string, toUpper:char -> char}"),
>    ("DESC","forall 'a. 'a -> 'a descending"),("EQUAL","order"),
>    ("Either",
>     "{app:forall 'a 'b 'c. ('a -> unit) * ('b -> unit) -> ('a,'b) either -> unit, appLeft:forall 'a 'b. ('a -> unit) -> ('a,'b) either -> unit, appRight:forall 'a 'b. ('b -> unit) -> ('a,'b) either -> unit, asLeft:forall 'a 'b. ('a,'b) either -> 'a option, asRight:forall 'a 'b. ('a,'b) either -> 'b option, fold:forall 'a 'b 'c. ('a * 'b -> 'b) * ('c * 'b -> 'b) -> 'b -> ('a,'c) either -> 'b, isLeft:forall 'a 'b. ('a,'b) either -> bool, isRight:forall 'a 'b. ('a,'b) either -> bool, map:forall 'a 'b 'c 'd. ('a -> 'c) * ('b -> 'd) -> ('a,'b) either -> ('c,'d) either, mapLeft:forall 'a 'b 'c. ('a -> 'b) -> ('a,'c) either -> ('b,'c) either, mapRight:forall 'a 'b 'c. ('b -> 'c) -> ('a,'b) either -> ('a,'c) either, partition:forall 'a 'b. ('a,'b) either list -> 'a list * 'b list, proj:forall 'a. ('a,'a) either -> 'a}"),
>    ("Fn",
>     "{apply:forall 'a 'b. ('a -> 'b) * 'a -> 'b, const:forall 'a 'b. 'a -> 'b -> 'a, curry:forall 'a 'b 'c. ('a * 'b -> 'c) -> 'a -> 'b -> 'c, equal:forall 'a 'b. 'a -> 'a -> bool, flip:forall 'a 'b 'c. ('a * 'b -> 'c) -> 'b * 'a -> 'c, id:forall 'a. 'a -> 'a, notEqual:forall 'a 'b. 'a -> 'a -> bool, `op o`:forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c, repeat:forall 'a. int -> ('a -> 'a) -> 'a -> 'a, uncurry:forall 'a 'b 'c. ('a -> 'b -> 'c) -> 'a * 'b -> 'c}"),
>    ("GREATER","order"),
>    ("General",
>     "{ignore:forall 'a. 'a -> unit, `op o`:forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c}"),
>    ("INL","forall 'a 'b. 'a -> ('a,'b) either"),
>    ("INR","forall 'a 'b. 'b -> ('a,'b) either"),
>    ("Int",
>     "{abs:int -> int, compare:int * int -> order, div:int * int -> int, fromInt:int -> int, fromLarge:int -> int, fromString:string -> int option, max:int * int -> int, maxInt:int option, min:int * int -> int, minInt:int option, mod:int * int -> int, precision:int option, quot:int * int -> int, rem:int * int -> int, sameSign:int * int -> bool, sign:int -> int, toInt:int -> int, toLarge:int -> int, toString:int -> string}"),
>    ("Interact","{use:string -> unit, useSilently:string -> unit}"),
>    ("LESS","order"),
>    ("List",
>     "{all:forall 'a. ('a -> bool) -> 'a list -> bool, app:forall 'a. ('a -> unit) -> 'a list -> unit, at:forall 'a. 'a list * 'a list -> 'a list, collate:forall 'a. ('a * 'a -> order) -> 'a list * 'a list -> order, concat:forall 'a. 'a list list -> 'a list, drop:forall 'a. 'a list * int -> 'a list, except:forall 'a. 'a list list -> 'a list, exists:forall 'a. ('a -> bool) -> 'a list -> bool, filter:forall 'a. ('a -> bool) -> 'a list -> 'a list, find:forall 'a. ('a -> bool) -> 'a list -> 'a option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, getItem:forall 'a. 'a list -> ('a * 'a list) option, hd:forall 'a. 'a list -> 'a, intersect:forall 'a. 'a list list -> 'a list, last:forall 'a. 'a list -> 'a, length:forall 'a. 'a list -> int, map:forall 'a 'b. ('a -> 'b) -> 'a list -> 'b list, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a list -> 'b list, mapi:forall 'a 'b. (int * 'a -> 'b) -> 'a list -> 'b list, nil:forall 'a. 'a list, nth:forall 'a. 'a list * int -> 'a, null:forall 'a. 'a list -> bool, `op @`:forall 'a. 'a list * 'a list -> 'a list, partition:forall 'a. ('a -> bool) -> 'a list -> 'a list * 'a list, rev:forall 'a. 'a list -> 'a list, revAppend:forall 'a. 'a list * 'a list -> 'a list, tabulate:forall 'a. int * (int -> 'a) -> 'a list, take:forall 'a. 'a list * int -> 'a list, tl:forall 'a. 'a list -> 'a list}"),
>    ("ListPair",
>     "{all:forall 'a 'b. ('a * 'b -> bool) -> 'a list * 'b list -> bool, allEq:forall 'a 'b. ('a * 'b -> bool) -> 'a list * 'b list -> bool, app:forall 'a 'b. ('a * 'b -> unit) -> 'a list * 'b list -> unit, appEq:forall 'a 'b. ('a * 'b -> unit) -> 'a list * 'b list -> unit, exists:forall 'a 'b. ('a * 'b -> bool) -> 'a list * 'b list -> bool, foldl:forall 'a 'b 'c. ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c, foldlEq:forall 'a 'b 'c. ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c, foldr:forall 'a 'b 'c. ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c, foldrEq:forall 'a 'b 'c. ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c, map:forall 'a 'b 'c. ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list, mapEq:forall 'a 'b 'c. ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list, unzip:forall 'a 'b. ('a * 'b) list -> 'a list * 'b list, zip:forall 'a 'b. 'a list * 'b list -> ('a * 'b) list, zipEq:forall 'a 'b. 'a list * 'b list -> ('a * 'b) list}"),
>    ("Math",
>     "{acos:real -> real, asin:real -> real, atan:real -> real, atan2:real * real -> real, cos:real -> real, cosh:real -> real, e:real, exp:real -> real, ln:real -> real, log10:real -> real, pi:real, pow:real * real -> real, sin:real -> real, sinh:real -> real, sqrt:real -> real, tan:real -> real, tanh:real -> real}"),
>    ("NONE","'a option"),
>    ("Option",
>     "{app:forall 'a. ('a option -> unit) -> 'a option -> unit, compose:forall 'a 'b 'c. ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option, composePartial:forall 'a 'b 'c. ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option, filter:forall 'a. ('a -> bool) -> 'a -> 'a option, getOpt:forall 'a. 'a option * 'a -> 'a, isSome:forall 'a. 'a option -> bool, join:forall 'a. 'a option option -> 'a option, map:forall 'a 'b. ('a -> 'b) -> 'a option -> 'b option, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a option -> 'b option, valOf:forall 'a. 'a option -> 'a}"),
>    ("Real",
>     "{abs:real -> real, ceil:real -> int, checkFloat:real -> real, compare:real * real -> order, copySign:real * real -> real, floor:real -> int, fromInt:int -> real, fromManExp:{exp:int, man:real} -> real, fromString:string -> real option, isFinite:real -> bool, isNan:real -> bool, isNormal:real -> bool, max:real * real -> real, maxFinite:real, min:real * real -> real, minNormalPos:real, minPos:real, negInf:real, posInf:real, precision:int, radix:int, realCeil:real -> real, realFloor:real -> real, realMod:real -> real, realRound:real -> real, realTrunc:real -> real, rem:real * real -> real, round:real -> int, sameSign:real * real -> bool, sign:real -> int, signBit:real -> bool, split:real -> {frac:real, whole:real}, toManExp:real -> {exp:int, man:real}, toString:real -> string, trunc:real -> int, unordered:real * real -> bool}"),
>    ("Relational",
>     "{compare:forall 'a. 'a * 'a -> order, count:multi(forall 'a. 'a bag -> int,forall 'a. 'a list -> int), empty:multi(forall 'a. 'a bag -> bool,forall 'a. 'a list -> bool), iterate:multi(forall 'a. 'a bag -> ('a bag * 'a bag -> 'a bag) -> 'a bag,forall 'a. 'a list -> ('a list * 'a list -> 'a list) -> 'a list), max:multi(forall 'a. 'a bag -> 'a,forall 'a. 'a list -> 'a), min:multi(forall 'a. 'a bag -> 'a,forall 'a. 'a list -> 'a), nonEmpty:multi(forall 'a. 'a bag -> bool,forall 'a. 'a list -> bool), only:multi(forall 'a. 'a bag -> 'a,forall 'a. 'a list -> 'a), sum:multi(forall 'a. 'a bag -> 'a,forall 'a. 'a list -> 'a)}"),
>    ("SOME","forall 'a. 'a -> 'a option"),
>    ("String",
>     "{collate:(char * char -> order) -> string * string -> order, compare:string * string -> order, concat:string list -> string, concatWith:string -> string list -> string, explode:string -> char list, extract:string * int * int option -> string, fields:(char -> bool) -> string -> string list, implode:char list -> string, isPrefix:string -> string -> bool, isSubstring:string -> string -> bool, isSuffix:string -> string -> bool, map:(char -> char) -> string -> string, maxSize:int, `op <`:string * string -> bool, `op <=`:string * string -> bool, `op >`:string * string -> bool, `op >=`:string * string -> bool, `op ^`:string * string -> string, size:string -> int, str:char -> string, sub:string * int -> char, substring:string * int * int -> string, tokens:(char -> bool) -> string -> string list, translate:(char -> string) -> string -> string}"),
>    ("Sys",
>     "{clearEnv:unit -> unit, env:unit -> (string * string) list, file:{...}, plan:unit -> string, set:forall 'a. string * 'a -> unit, show:string -> string option, showAll:unit -> (string * string option) list, unset:string -> unit}"),
>    ("Vector",
>     "{all:forall 'a. ('a -> bool) -> 'a vector -> bool, app:forall 'a. ('a -> unit) -> 'a vector -> unit, appi:forall 'a. (int * 'a -> unit) -> 'a vector -> unit, collate:forall 'a. ('a * 'a -> order) -> 'a vector * 'a vector -> order, concat:forall 'a. 'a vector list -> 'a vector, exists:forall 'a. ('a -> bool) -> 'a vector -> bool, find:forall 'a. ('a -> bool) -> 'a vector -> 'a option, findi:forall 'a 'b. (int * 'a -> bool) -> 'a vector -> (int * 'a) option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldli:forall 'a 'b. (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldri:forall 'a 'b. (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b, fromList:forall 'a. 'a list -> 'a vector, length:forall 'a. 'a vector -> int, map:forall 'a 'b. ('a -> 'b) -> 'a vector -> 'b vector, mapi:forall 'a 'b. (int * 'a -> 'b) -> 'a vector -> 'b vector, maxLen:int, sub:forall 'a. 'a vector * int -> 'a, tabulate:forall 'a. int * (int -> 'a) -> 'a vector, update:forall 'a. 'a vector * int * 'a -> 'a vector}"),
>    ("abs","int -> int"),("app","forall 'a. ('a -> unit) -> 'a list -> unit"),
>    ("bag","forall 'a. 'a list -> 'a bag"),("ceil","real -> int"),
>    ("chr","int -> char"),("compare","forall 'a. 'a * 'a -> order"),
>    ("concat","string list -> string"),("count","forall 'a. 'a bag -> int"),
>    ("emps","{empno:int, ename:string, mgr:int} list"),
>    ("empty","forall 'a. 'a bag -> bool"),
>    ("env","unit -> (string * string) list"),("explode","string -> char list"),
>    ("f","real -> int * int * int * int"),("false","bool"),
>    ("fields","(char -> bool) -> string -> string list"),("file","{...}"),
>    ("floor","real -> int"),
>    ("foldl","forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b"),
>    ("foldr","forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b"),
>    ("getOpt","forall 'a. 'a option * 'a -> 'a"),
>    ("hd","forall 'a. 'a list -> 'a"),("ignore","forall 'a. 'a -> unit"),
>    ("implode","char list -> string"),("isSome","forall 'a. 'a option -> bool"),
>    ("it","unit -> (string * string) list"),
>    ("iterate","forall 'a. 'a bag -> ('a bag * 'a bag -> 'a bag) -> 'a bag"),
>    ("length","forall 'a. 'a list -> int"),
>    ("map","forall 'a 'b. ('a -> 'b) -> 'a list -> 'b list"),
>    ("max","forall 'a. 'a bag -> 'a"),("min","forall 'a. 'a bag -> 'a"),
>    ("nan","real"),("nonEmpty","forall 'a. 'a bag -> bool"),
>    ("noneInt","int option"),("not","bool -> bool"),
>    ("null","forall 'a. 'a list -> bool"),("only","forall 'a. 'a bag -> 'a"),
>    ("op *","forall 'a. 'a * 'a -> 'a"),("op +","forall 'a. 'a * 'a -> 'a"),
>    ("op -","forall 'a. 'a * 'a -> 'a"),("op /","forall 'a. 'a * 'a -> 'a"),
>    ("op ::","forall 'a. 'a * 'a list -> 'a list"),
>    ("op <","forall 'a. 'a * 'a -> bool"),
>    ("op <=","forall 'a. 'a * 'a -> bool"),
>    ("op <>","forall 'a. 'a * 'a -> bool"),
>    ("op =","forall 'a. 'a * 'a -> bool"),("op >","forall 'a. 'a * 'a -> bool"),
>    ("op >=","forall 'a. 'a * 'a -> bool"),
>    ("op @","forall 'a. 'a list * 'a list -> 'a list"),
>    ("op ^","string * string -> string"),("op div","int * int -> int"),
>    ("op elem","forall 'a. 'a * 'a bag -> bool"),("op mod","int * int -> int"),
>    ("op notelem","forall 'a. 'a * 'a bag -> bool"),
>    ("op o","forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c"),
>    ("op ~","forall 'a. 'a -> 'a"),("p","char -> bool"),
>    ("plan","unit -> string"),("plusOne","int -> int"),
>    ("plusThree","int -> int"),("print","forall 'a. 'a -> unit"),
>    ("real","int -> real"),("rev","forall 'a. 'a list -> 'a list"),
>    ("round","real -> int"),("set","forall 'a. string * 'a -> unit"),
>    ("show","string -> string option"),
>    ("showAll","unit -> (string * string option) list"),
>    ("size","string -> int"),("str","char -> string"),
>    ("substring","string * int * int -> string"),
>    ("sum","forall 'a. 'a bag -> 'a"),("ten","(bool,int) either"),
>    ("testChar","(char -> bool) -> (bool * string) list"),
>    ("timesTwo","int -> int"),("tl","forall 'a. 'a list -> 'a list"),
>    ("tokens","(char -> bool) -> string -> string list"),("true","bool"),
>    ("trunc","real -> int"),("unset","string -> unit"),("use","string -> unit"),
>    ("useSilently","string -> unit"),("valOf","forall 'a. 'a option -> 'a"),
>    ("vector","forall 'a. 'a list -> 'a vector"),("yes","(bool,int) either")]
>   : (string * string) list

env;
> val it = fn : unit -> (string * string) list
env ();
> val it =
>   [
>    ("Bag",
>     "{all:forall 'a. ('a -> bool) -> 'a bag -> bool, app:forall 'a. ('a -> unit) -> 'a bag -> unit, at:forall 'a. 'a bag * 'a bag -> 'a bag, concat:forall 'a. 'a bag list -> 'a bag, drop:forall 'a. 'a bag * int -> 'a bag, exists:forall 'a. ('a -> bool) -> 'a bag -> bool, filter:forall 'a. ('a -> bool) -> 'a bag -> 'a bag, find:forall 'a. ('a -> bool) -> 'a bag -> 'a option, fold:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a bag -> 'b, fromList:forall 'a. 'a list -> 'a bag, getItem:forall 'a. 'a bag -> ('a * 'a bag) option, hd:forall 'a. 'a bag -> 'a, length:forall 'a. 'a bag -> int, map:forall 'a 'b. ('a -> 'b) -> 'a bag -> 'b bag, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a bag -> 'b bag, nil:forall 'a. 'a bag, nth:forall 'a. 'a bag * int -> 'a, null:forall 'a. 'a bag -> bool, `op @`:forall 'a. 'a bag * 'a bag -> 'a bag, partition:forall 'a. ('a -> bool) -> 'a bag -> 'a bag * 'a bag, tabulate:forall 'a. int * (int -> 'a) -> 'a bag, take:forall 'a. 'a bag * int -> 'a bag, tl:forall 'a. 'a bag -> 'a bag, toList:forall 'a. 'a bag -> 'a list}"),
>    ("Char",
>     "{chr:int -> char, compare:char * char -> order, contains:string -> char -> bool, fromCString:string -> char option, fromString:string -> char option, isAlpha:char -> bool, isAlphaNum:char -> bool, isAscii:char -> bool, isCntrl:char -> bool, isDigit:char -> bool, isGraph:char -> bool, isHexDigit:char -> bool, isLower:char -> bool, isPrint:char -> bool, isPunct:char -> bool, isSpace:char -> bool, isUpper:char -> bool, maxChar:char, maxOrd:int, minChar:char, notContains:string -> char -> bool, `op <`:char * char -> bool, `op <=`:char * char -> bool, `op >`:char * char -> bool, `op >=`:char * char -> bool, ord:char -> int, pred:char -> char, succ:char -> char, toCString:char -> string, toLower:char -> char, toString:char -> string, toUpper:char -> char}"),
>    ("DESC","forall 'a. 'a -> 'a descending"),("EQUAL","order"),
>    ("Either",
>     "{app:forall 'a 'b 'c. ('a -> unit) * ('b -> unit) -> ('a,'b) either -> unit, appLeft:forall 'a 'b. ('a -> unit) -> ('a,'b) either -> unit, appRight:forall 'a 'b. ('b -> unit) -> ('a,'b) either -> unit, asLeft:forall 'a 'b. ('a,'b) either -> 'a option, asRight:forall 'a 'b. ('a,'b) either -> 'b option, fold:forall 'a 'b 'c. ('a * 'b -> 'b) * ('c * 'b -> 'b) -> 'b -> ('a,'c) either -> 'b, isLeft:forall 'a 'b. ('a,'b) either -> bool, isRight:forall 'a 'b. ('a,'b) either -> bool, map:forall 'a 'b 'c 'd. ('a -> 'c) * ('b -> 'd) -> ('a,'b) either -> ('c,'d) either, mapLeft:forall 'a 'b 'c. ('a -> 'b) -> ('a,'c) either -> ('b,'c) either, mapRight:forall 'a 'b 'c. ('b -> 'c) -> ('a,'b) either -> ('a,'c) either, partition:forall 'a 'b. ('a,'b) either list -> 'a list * 'b list, proj:forall 'a. ('a,'a) either -> 'a}"),
>    ("Fn",
>     "{apply:forall 'a 'b. ('a -> 'b) * 'a -> 'b, const:forall 'a 'b. 'a -> 'b -> 'a, curry:forall 'a 'b 'c. ('a * 'b -> 'c) -> 'a -> 'b -> 'c, equal:forall 'a 'b. 'a -> 'a -> bool, flip:forall 'a 'b 'c. ('a * 'b -> 'c) -> 'b * 'a -> 'c, id:forall 'a. 'a -> 'a, notEqual:forall 'a 'b. 'a -> 'a -> bool, `op o`:forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c, repeat:forall 'a. int -> ('a -> 'a) -> 'a -> 'a, uncurry:forall 'a 'b 'c. ('a -> 'b -> 'c) -> 'a * 'b -> 'c}"),
>    ("GREATER","order"),
>    ("General",
>     "{ignore:forall 'a. 'a -> unit, `op o`:forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c}"),
>    ("INL","forall 'a 'b. 'a -> ('a,'b) either"),
>    ("INR","forall 'a 'b. 'b -> ('a,'b) either"),
>    ("Int",
>     "{abs:int -> int, compare:int * int -> order, div:int * int -> int, fromInt:int -> int, fromLarge:int -> int, fromString:string -> int option, max:int * int -> int, maxInt:int option, min:int * int -> int, minInt:int option, mod:int * int -> int, precision:int option, quot:int * int -> int, rem:int * int -> int, sameSign:int * int -> bool, sign:int -> int, toInt:int -> int, toLarge:int -> int, toString:int -> string}"),
>    ("Interact","{use:string -> unit, useSilently:string -> unit}"),
>    ("LESS","order"),
>    ("List",
>     "{all:forall 'a. ('a -> bool) -> 'a list -> bool, app:forall 'a. ('a -> unit) -> 'a list -> unit, at:forall 'a. 'a list * 'a list -> 'a list, collate:forall 'a. ('a * 'a -> order) -> 'a list * 'a list -> order, concat:forall 'a. 'a list list -> 'a list, drop:forall 'a. 'a list * int -> 'a list, except:forall 'a. 'a list list -> 'a list, exists:forall 'a. ('a -> bool) -> 'a list -> bool, filter:forall 'a. ('a -> bool) -> 'a list -> 'a list, find:forall 'a. ('a -> bool) -> 'a list -> 'a option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, getItem:forall 'a. 'a list -> ('a * 'a list) option, hd:forall 'a. 'a list -> 'a, intersect:forall 'a. 'a list list -> 'a list, last:forall 'a. 'a list -> 'a, length:forall 'a. 'a list -> int, map:forall 'a 'b. ('a -> 'b) -> 'a list -> 'b list, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a list -> 'b list, mapi:forall 'a 'b. (int * 'a -> 'b) -> 'a list -> 'b list, nil:forall 'a. 'a list, nth:forall 'a. 'a list * int -> 'a, null:forall 'a. 'a list -> bool, `op @`:forall 'a. 'a list * 'a list -> 'a list, partition:forall 'a. ('a -> bool) -> 'a list -> 'a list * 'a list, rev:forall 'a. 'a list -> 'a list, revAppend:forall 'a. 'a list * 'a list -> 'a list, tabulate:forall 'a. int * (int -> 'a) -> 'a list, take:forall 'a. 'a list * int -> 'a list, tl:forall 'a. 'a list -> 'a list}"),
>    ("ListPair",
>     "{all:forall 'a 'b. ('a * 'b -> bool) -> 'a list * 'b list -> bool, allEq:forall 'a 'b. ('a * 'b -> bool) -> 'a list * 'b list -> bool, app:forall 'a 'b. ('a * 'b -> unit) -> 'a list * 'b list -> unit, appEq:forall 'a 'b. ('a * 'b -> unit) -> 'a list * 'b list -> unit, exists:forall 'a 'b. ('a * 'b -> bool) -> 'a list * 'b list -> bool, foldl:forall 'a 'b 'c. ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c, foldlEq:forall 'a 'b 'c. ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c, foldr:forall 'a 'b 'c. ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c, foldrEq:forall 'a 'b 'c. ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c, map:forall 'a 'b 'c. ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list, mapEq:forall 'a 'b 'c. ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list, unzip:forall 'a 'b. ('a * 'b) list -> 'a list * 'b list, zip:forall 'a 'b. 'a list * 'b list -> ('a * 'b) list, zipEq:forall 'a 'b. 'a list * 'b list -> ('a * 'b) list}"),
>    ("Math",
>     "{acos:real -> real, asin:real -> real, atan:real -> real, atan2:real * real -> real, cos:real -> real, cosh:real -> real, e:real, exp:real -> real, ln:real -> real, log10:real -> real, pi:real, pow:real * real -> real, sin:real -> real, sinh:real -> real, sqrt:real -> real, tan:real -> real, tanh:real -> real}"),
>    ("NONE","'a option"),
>    ("Option",
>     "{app:forall 'a. ('a option -> unit) -> 'a option -> unit, compose:forall 'a 'b 'c. ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option, composePartial:forall 'a 'b 'c. ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option, filter:forall 'a. ('a -> bool) -> 'a -> 'a option, getOpt:forall 'a. 'a option * 'a -> 'a, isSome:forall 'a. 'a option -> bool, join:forall 'a. 'a option option -> 'a option, map:forall 'a 'b. ('a -> 'b) -> 'a option -> 'b option, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a option -> 'b option, valOf:forall 'a. 'a option -> 'a}"),
>    ("Real",
>     "{abs:real -> real, ceil:real -> int, checkFloat:real -> real, compare:real * real -> order, copySign:real * real -> real, floor:real -> int, fromInt:int -> real, fromManExp:{exp:int, man:real} -> real, fromString:string -> real option, isFinite:real -> bool, isNan:real -> bool, isNormal:real -> bool, max:real * real -> real, maxFinite:real, min:real * real -> real, minNormalPos:real, minPos:real, negInf:real, posInf:real, precision:int, radix:int, realCeil:real -> real, realFloor:real -> real, realMod:real -> real, realRound:real -> real, realTrunc:real -> real, rem:real * real -> real, round:real -> int, sameSign:real * real -> bool, sign:real -> int, signBit:real -> bool, split:real -> {frac:real, whole:real}, toManExp:real -> {exp:int, man:real}, toString:real -> string, trunc:real -> int, unordered:real * real -> bool}"),
>    ("Relational",
>     "{compare:forall 'a. 'a * 'a -> order, count:multi(forall 'a. 'a bag -> int,forall 'a. 'a list -> int), empty:multi(forall 'a. 'a bag -> bool,forall 'a. 'a list -> bool), iterate:multi(forall 'a. 'a bag -> ('a bag * 'a bag -> 'a bag) -> 'a bag,forall 'a. 'a list -> ('a list * 'a list -> 'a list) -> 'a list), max:multi(forall 'a. 'a bag -> 'a,forall 'a. 'a list -> 'a), min:multi(forall 'a. 'a bag -> 'a,forall 'a. 'a list -> 'a), nonEmpty:multi(forall 'a. 'a bag -> bool,forall 'a. 'a list -> bool), only:multi(forall 'a. 'a bag -> 'a,forall 'a. 'a list -> 'a), sum:multi(forall 'a. 'a bag -> 'a,forall 'a. 'a list -> 'a)}"),
>    ("SOME","forall 'a. 'a -> 'a option"),
>    ("String",
>     "{collate:(char * char -> order) -> string * string -> order, compare:string * string -> order, concat:string list -> string, concatWith:string -> string list -> string, explode:string -> char list, extract:string * int * int option -> string, fields:(char -> bool) -> string -> string list, implode:char list -> string, isPrefix:string -> string -> bool, isSubstring:string -> string -> bool, isSuffix:string -> string -> bool, map:(char -> char) -> string -> string, maxSize:int, `op <`:string * string -> bool, `op <=`:string * string -> bool, `op >`:string * string -> bool, `op >=`:string * string -> bool, `op ^`:string * string -> string, size:string -> int, str:char -> string, sub:string * int -> char, substring:string * int * int -> string, tokens:(char -> bool) -> string -> string list, translate:(char -> string) -> string -> string}"),
>    ("Sys",
>     "{clearEnv:unit -> unit, env:unit -> (string * string) list, file:{...}, plan:unit -> string, set:forall 'a. string * 'a -> unit, show:string -> string option, showAll:unit -> (string * string option) list, unset:string -> unit}"),
>    ("Vector",
>     "{all:forall 'a. ('a -> bool) -> 'a vector -> bool, app:forall 'a. ('a -> unit) -> 'a vector -> unit, appi:forall 'a. (int * 'a -> unit) -> 'a vector -> unit, collate:forall 'a. ('a * 'a -> order) -> 'a vector * 'a vector -> order, concat:forall 'a. 'a vector list -> 'a vector, exists:forall 'a. ('a -> bool) -> 'a vector -> bool, find:forall 'a. ('a -> bool) -> 'a vector -> 'a option, findi:forall 'a 'b. (int * 'a -> bool) -> 'a vector -> (int * 'a) option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldli:forall 'a 'b. (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b, foldri:forall 'a 'b. (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b, fromList:forall 'a. 'a list -> 'a vector, length:forall 'a. 'a vector -> int, map:forall 'a 'b. ('a -> 'b) -> 'a vector -> 'b vector, mapi:forall 'a 'b. (int * 'a -> 'b) -> 'a vector -> 'b vector, maxLen:int, sub:forall 'a. 'a vector * int -> 'a, tabulate:forall 'a. int * (int -> 'a) -> 'a vector, update:forall 'a. 'a vector * int * 'a -> 'a vector}"),
>    ("abs","int -> int"),("app","forall 'a. ('a -> unit) -> 'a list -> unit"),
>    ("bag","forall 'a. 'a list -> 'a bag"),("ceil","real -> int"),
>    ("chr","int -> char"),("compare","forall 'a. 'a * 'a -> order"),
>    ("concat","string list -> string"),("count","forall 'a. 'a bag -> int"),
>    ("emps","{empno:int, ename:string, mgr:int} list"),
>    ("empty","forall 'a. 'a bag -> bool"),
>    ("env","unit -> (string * string) list"),("explode","string -> char list"),
>    ("f","real -> int * int * int * int"),("false","bool"),
>    ("fields","(char -> bool) -> string -> string list"),("file","{...}"),
>    ("floor","real -> int"),
>    ("foldl","forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b"),
>    ("foldr","forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b"),
>    ("getOpt","forall 'a. 'a option * 'a -> 'a"),
>    ("hd","forall 'a. 'a list -> 'a"),("ignore","forall 'a. 'a -> unit"),
>    ("implode","char list -> string"),("isSome","forall 'a. 'a option -> bool"),
>    ("it","unit -> (string * string) list"),
>    ("iterate","forall 'a. 'a bag -> ('a bag * 'a bag -> 'a bag) -> 'a bag"),
>    ("length","forall 'a. 'a list -> int"),
>    ("map","forall 'a 'b. ('a -> 'b) -> 'a list -> 'b list"),
>    ("max","forall 'a. 'a bag -> 'a"),("min","forall 'a. 'a bag -> 'a"),
>    ("nan","real"),("nonEmpty","forall 'a. 'a bag -> bool"),
>    ("noneInt","int option"),("not","bool -> bool"),
>    ("null","forall 'a. 'a list -> bool"),("only","forall 'a. 'a bag -> 'a"),
>    ("op *","forall 'a. 'a * 'a -> 'a"),("op +","forall 'a. 'a * 'a -> 'a"),
>    ("op -","forall 'a. 'a * 'a -> 'a"),("op /","forall 'a. 'a * 'a -> 'a"),
>    ("op ::","forall 'a. 'a * 'a list -> 'a list"),
>    ("op <","forall 'a. 'a * 'a -> bool"),
>    ("op <=","forall 'a. 'a * 'a -> bool"),
>    ("op <>","forall 'a. 'a * 'a -> bool"),
>    ("op =","forall 'a. 'a * 'a -> bool"),("op >","forall 'a. 'a * 'a -> bool"),
>    ("op >=","forall 'a. 'a * 'a -> bool"),
>    ("op @","forall 'a. 'a list * 'a list -> 'a list"),
>    ("op ^","string * string -> string"),("op div","int * int -> int"),
>    ("op elem","forall 'a. 'a * 'a bag -> bool"),("op mod","int * int -> int"),
>    ("op notelem","forall 'a. 'a * 'a bag -> bool"),
>    ("op o","forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c"),
>    ("op ~","forall 'a. 'a -> 'a"),("p","char -> bool"),
>    ("plan","unit -> string"),("plusOne","int -> int"),
>    ("plusThree","int -> int"),("print","forall 'a. 'a -> unit"),
>    ("real","int -> real"),("rev","forall 'a. 'a list -> 'a list"),
>    ("round","real -> int"),("set","forall 'a. string * 'a -> unit"),
>    ("show","string -> string option"),
>    ("showAll","unit -> (string * string option) list"),
>    ("size","string -> int"),("str","char -> string"),
>    ("substring","string * int * int -> string"),
>    ("sum","forall 'a. 'a bag -> 'a"),("ten","(bool,int) either"),
>    ("testChar","(char -> bool) -> (bool * string) list"),
>    ("timesTwo","int -> int"),("tl","forall 'a. 'a list -> 'a list"),
>    ("tokens","(char -> bool) -> string -> string list"),("true","bool"),
>    ("trunc","real -> int"),("unset","string -> unit"),("use","string -> unit"),
>    ("useSilently","string -> unit"),("valOf","forall 'a. 'a option -> 'a"),
>    ("vector","forall 'a. 'a list -> 'a vector"),("yes","(bool,int) either")]
>   : (string * string) list

(*) val plan : unit -> string
Sys.plan;
> val it = fn : unit -> string
1 + 2;
> val it = 3 : int
Sys.plan ();
> val it = "apply2(fnValue +, constant(1), constant(2))" : string

(*) val set : string * 'a -> unit
Sys.set;
> val it = fn : string * 'a -> unit
Sys.set ("hybrid", false);
> val it = () : unit
Sys.plan ();
> val it =
>   "apply(fnValue Sys.set, argCode tuple(constant(hybrid), constant(false)))"
>   : string

(*) val show : string -> string option
Sys.show;
> val it = fn : string -> string option
show;
> val it = fn : string -> string option
Sys.show "hybrid";
> val it = SOME "false" : string option
Sys.set ("hybrid", true);
> val it = () : unit
Sys.show "hybrid";
> val it = SOME "true" : string option
Sys.show "optionalInt";
> val it = NONE : string option
Sys.plan ();
> val it = "apply(fnValue Sys.show, argCode constant(optionalInt))" : string

(*) val showAll : unit -> string * string option list
Sys.showAll;
> val it = fn : unit -> (string * string option) list
showAll;
> val it = fn : unit -> (string * string option) list
map
  (fn (p,v) =>
    (p, if p = "directory" orelse p = "scriptDirectory" then SOME "?" else v))
  (Sys.showAll ());
> val it =
>   [("directory",SOME "?"),("hybrid",SOME "true"),("inlinePassCount",SOME "5"),
>    ("lineWidth",SOME "78"),("matchCoverageEnabled",SOME "true"),
>    ("optionalInt",NONE),("output",SOME "CLASSIC"),("printDepth",SOME "5"),
>    ("printLength",SOME "999"),("relationalize",SOME "false"),
>    ("scriptDirectory",SOME "?"),("stringDepth",SOME "-1")]
>   : (string * string option) list
List.length (Sys.showAll ());
> val it = 12 : int
List.length (showAll ());
> val it = 12 : int
Sys.plan ();
> val it =
>   "apply(fnValue List.length, argCode apply(fnValue Sys.showAll, argCode constant([])))"
>   : string

Sys.set ("optionalInt", ~5);
> val it = () : unit
Sys.show "optionalInt";
> val it = SOME "-5" : string option

(*) val unset : string -> unit
Sys.unset;
> val it = fn : string -> unit
Sys.unset "hybrid";
> val it = () : unit
Sys.unset "optionalInt";
> val it = () : unit
Sys.plan ();
> val it = "apply(fnValue Sys.unset, argCode constant(optionalInt))" : string

(* Vector ------------------------------------------------------ *)

(*) Vector.fromList : 'a list -> 'a vector
Vector.fromList;
> val it = fn : 'a list -> 'a vector
Vector.fromList ["a", "", "bc"];
> val it = #["a","","bc"] : string vector
Vector.fromList [1,2];
> val it = #[1,2] : int vector
Sys.plan ();
> val it =
>   "apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(2)))"
>   : string

(*) "vector" is shorthand for "Vector.fromList"
vector [1,2];
> val it = #[1,2] : int vector

(* supported in sml-nj but not morel:
 #[1,2];
 *)

(* sml-nj says:
  stdIn:3.1-3.19 Warning: type vars not generalized because of
     value restriction are instantiated to dummy types (X1,X2,...)
  val it = #[] : ?.X1 vector
*)
Vector.fromList [];
> val it = #[] : 'a vector
Sys.plan ();
> val it = "apply(fnValue Vector.fromList, argCode tuple)" : string

(*) Vector.maxLen: int
Vector.maxLen;
> val it = 16777215 : int
Sys.plan ();
> val it = "constant(16777215)" : string

(*) Vector.tabulate : int * (int -> 'a) -> 'a vector
Vector.tabulate;
> val it = fn : int * (int -> 'a) -> 'a vector
Vector.tabulate (5, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
> val it = #[1,1,2,6,24] : int vector
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.tabulate, constant(5), let1(matchCode match(fact, match(n, apply(fnCode match(true, constant(1), _, apply2(fnValue *, get(name n), apply(fnCode link, argCode apply2(fnValue -, get(name n), constant(1))))), argCode apply2(fnValue =, get(name n), constant(0))))), resultCode get(name fact)))"
>   : string

(*) Vector.length : 'a vector -> int
Vector.length;
> val it = fn : 'a vector -> int
Vector.length (Vector.fromList [1,2,3]);
> val it = 3 : int
Sys.plan ();
> val it =
>   "apply(fnValue Vector.length, argCode apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(2), constant(3))))"
>   : string

(*) Vector.sub : 'a vector * int -> 'a
Vector.sub;
> val it = fn : 'a vector * int -> 'a
Vector.sub (Vector.fromList [3,6,9], 2);
> val it = 9 : int
Vector.sub (Vector.fromList [3,6,9], ~1);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.41
Vector.sub (Vector.fromList [3,6,9], 3);
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.40
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.sub, apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(6), constant(9))), constant(3))"
>   : string

(*) Vector.update : 'a vector * int * 'a -> 'a vector
Vector.update;
> val it = fn : 'a vector * int * 'a -> 'a vector
Vector.update (Vector.fromList ["a","b","c"], 1, "baz");
> val it = #["a","baz","c"] : string vector
Vector.update (Vector.fromList ["a","b","c"], ~1, "baz");
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.57
Vector.update (Vector.fromList ["a","b","c"], 3, "baz");
> uncaught exception Subscript [subscript out of bounds]
>   raised at: stdIn:1.1-1.56
Sys.plan ();
> val it =
>   "apply3(fnValue Vector.update, apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))), constant(3), constant(baz))"
>   : string

(*) Vector.concat : 'a vector list -> 'a vector
Vector.concat;
> val it = fn : 'a vector list -> 'a vector
Vector.concat [Vector.fromList ["a","b"],
  Vector.fromList [], Vector.fromList ["c"]];
> val it = #["a","b","c"] : string vector
Sys.plan ();
> val it =
>   "apply(fnValue Vector.concat, argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b))), apply(fnValue Vector.fromList, argCode tuple), apply(fnValue Vector.fromList, argCode tuple(constant(c)))))"
>   : string

(*) Vector.appi : (int * 'a -> unit) -> 'a vector -> unit
Vector.appi;
> val it = fn : (int * 'a -> unit) -> 'a vector -> unit
Vector.appi (fn (i,s) => ignore s) (Vector.fromList ["a", "b", "c"]);
> val it = () : unit
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.appi, match(v, apply(fnCode match((i, s), apply(fnValue General.ignore, argCode get(name s))), argCode get(name v))), apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))))"
>   : string

(*) Vector.app  : ('a -> unit) -> 'a vector -> unit
Vector.app;
> val it = fn : ('a -> unit) -> 'a vector -> unit
Vector.app (fn s => ignore s) (Vector.fromList ["a", "b", "c"]);
> val it = () : unit
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.app, match(s, apply(fnValue General.ignore, argCode get(name s))), apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))))"
>   : string

(*) Vector.mapi : (int * 'a -> 'b) -> 'a vector -> 'b vector
Vector.mapi;
> val it = fn : (int * 'a -> 'b) -> 'a vector -> 'b vector
Vector.mapi (fn (i, s) => String.sub (s, i)) (Vector.fromList ["abc", "xyz"]);
> val it = #[#"a",#"y"] : char vector
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.mapi, match(v, apply(fnCode match((i, s), apply2(fnValue String.sub, get(name s), get(name i))), argCode get(name v))), apply(fnValue Vector.fromList, argCode tuple(constant(abc), constant(xyz))))"
>   : string

(*) Vector.map  : ('a -> 'b) -> 'a vector -> 'b vector
Vector.map;
> val it = fn : ('a -> 'b) -> 'a vector -> 'b vector
Vector.map (fn s => String.sub (s, 0)) (Vector.fromList ["abc", "xyz"]);
> val it = #[#"a",#"x"] : char vector
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.map, match(s, apply2(fnValue String.sub, get(name s), constant(0))), apply(fnValue Vector.fromList, argCode tuple(constant(abc), constant(xyz))))"
>   : string

(*) Vector.foldli : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldli;
> val it = fn : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldli (fn (i,j,a) => a + i * j) 0 (Vector.fromList [2,3,4]);
> val it = 11 : int
Sys.plan ();
> val it =
>   "apply3(fnValue Vector.foldli, match(v, apply(fnCode match((i, j, a), apply2(fnValue +, get(name a), apply2(fnValue *, get(name i), get(name j)))), argCode get(name v))), constant(0), apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
>   : string

(*) Vector.foldri : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldri;
> val it = fn : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldri (fn (i,j,a) => a + i * j) 0 (Vector.fromList [2,3,4]);
> val it = 11 : int
Sys.plan ();
> val it =
>   "apply3(fnValue Vector.foldri, match(v, apply(fnCode match((i, j, a), apply2(fnValue +, get(name a), apply2(fnValue *, get(name i), get(name j)))), argCode get(name v))), constant(0), apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
>   : string

(*) Vector.foldl  : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldl;
> val it = fn : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldl (fn (j,a) => a + j) 0 (Vector.fromList [2,3,4]);
> val it = 9 : int
Sys.plan ();
> val it =
>   "apply3(fnValue Vector.foldl, match(v, apply(fnCode match((j, a), apply2(fnValue +, get(name a), get(name j))), argCode get(name v))), constant(0), apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
>   : string

(*) Vector.foldr  : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldr;
> val it = fn : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldr (fn (j,a) => a + j) 0 (Vector.fromList [2,3,4]);
> val it = 9 : int
Sys.plan ();
> val it =
>   "apply3(fnValue Vector.foldr, match(v, apply(fnCode match((j, a), apply2(fnValue +, get(name a), get(name j))), argCode get(name v))), constant(0), apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
>   : string

(*) Vector.findi : (int * 'a -> bool) -> 'a vector -> (int * 'a) option
Vector.findi;
> val it = fn : (int * 'a -> bool) -> 'a vector -> (int * 'a) option
Vector.findi (fn (i,j) => j < i) (Vector.fromList [10,8,6,4,2]);
> val it = SOME (4,2) : (int * int) option
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.findi, match(v, apply(fnCode match((i, j), apply2(fnValue <, get(name j), get(name i))), argCode get(name v))), apply(fnValue Vector.fromList, argCode tuple(constant(10), constant(8), constant(6), constant(4), constant(2))))"
>   : string

(*) Vector.find  : ('a -> bool) -> 'a vector -> 'a option
Vector.find;
> val it = fn : ('a -> bool) -> 'a vector -> 'a option
Vector.find (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
> val it = SOME 8 : int option
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.find, match(j, apply2(fnValue =, apply2(fnValue mod, get(name j), constant(2)), constant(0))), apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
>   : string

(*) Vector.exists : ('a -> bool) -> 'a vector -> bool
Vector.`exists`;
> val it = fn : ('a -> bool) -> 'a vector -> bool
Vector.`exists` (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
> val it = true : bool
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.exists, match(j, apply2(fnValue =, apply2(fnValue mod, get(name j), constant(2)), constant(0))), apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
>   : string

(*) Vector.all : ('a -> bool) -> 'a vector -> bool
Vector.all;
> val it = fn : ('a -> bool) -> 'a vector -> bool
Vector.all (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
> val it = false : bool
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.all, match(j, apply2(fnValue =, apply2(fnValue mod, get(name j), constant(2)), constant(0))), apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
>   : string

(*) Vector.collate : ('a * 'a -> order) -> 'a vector * 'a vector -> order
Vector.collate;
> val it = fn : ('a * 'a -> order) -> 'a vector * 'a vector -> order
Vector.collate
  (fn (i,j) => if i < j then LESS else if i = j then EQUAL else GREATER)
  (Vector.fromList [1,3,5], Vector.fromList [1,3,6]);
> val it = LESS : order
Sys.plan ();
> val it =
>   "apply2(fnValue Vector.collate, match(v, apply(fnCode match((i, j), apply(fnCode match(true, constant([LESS]), _, apply(fnCode match(true, constant([EQUAL]), _, constant([GREATER])), argCode apply2(fnValue =, get(name i), get(name j)))), argCode apply2(fnValue <, get(name i), get(name j)))), argCode get(name v))), tuple(apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(3), constant(5))), apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(3), constant(6)))))"
>   : string

(*) End builtIn.smli
