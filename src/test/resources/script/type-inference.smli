(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *
 * Type inference tests.
 *
 * Generally, each test will use '>type' rather than '> val', so that
 * Morel just infers the type, and does not execute.
 *)
Sys.set ("lineWidth", 78);
> val it = () : unit

(* Test the test infrastructure.
 * ':t' can be on same line or previous line.
 * The expression is not executed, only type-checked.
 * Non-exhaustive matches are flagged. *)
:t 1;
> val it : int
:t
1;
> val it : int
:t 1 div 0;
> val it : int
:t 1.0 / 0.0;
> val it : real
:t fn 1 => "a";
> stdIn:1.14-1.25 Warning: match nonexhaustive
>   raised at: stdIn:1.14-1.25
> val it : int -> string

(*) Type tests
:t #"h";
> val it : char
:t "hello";
> val it : string
:t "hello"
 ^ ", world!";
> val it : string
:t
"hello"
 ^ ", world!";
> val it : string
:t 1;
> val it : int
:t ~1.0;
> val it : real
:t 6.02e~23;
> val it : real
:t ~6.02e~23;
> val it : real
:t ~6e~23;
> val it : real
:t 6e~23;
> val it : real
:t 6E~23;
> val it : real
:t 6E23;
> val it : real
:t ();
> val it : unit
:t true;
> val it : bool
:t false;
> val it : bool
:t (1);
> val it : int

:t (1, true);
> val it : int * bool
:t (false, 1, (true, false));
> val it : bool * int * (bool * bool)
:t (false, 1, (true, "a"), 2);
> val it : bool * int * (bool * string) * int
:t [1,2];
> val it : int list
:t [[1,2]];
> val it : int list list
:t [(1,2)];
> val it : (int * int) list
:t (1, [2]);
> val it : int * int list
:t (1, [2], 3);
> val it : int * int list * int
:t {a=1, b="two"};
> val it : {a:int, b:string}
:t fn () => 3;
> val it : unit -> int
:t fn () => fn () => 4;
> val it : unit -> unit -> int
:t (fn () => 5, fn () => 6);
> val it : (unit -> int) * (unit -> int)
:t fn () => (5, fn () => 6);
> val it : unit -> int * (unit -> int)
:t fn f => fn g => fn x => g (f x);
> val it : ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c
:t fn (f, g) => fn x => f (g x);
> val it : ('a -> 'b) * ('c -> 'a) -> 'c -> 'b
:t fn x: int => true;
> val it : int -> bool
:t fn (x: int, y: string) => (true, [1]);
> val it : int * string -> bool * int list
:t {f = fn () => 0, g = 1};
> val it : {f:unit -> int, g:int}
:t fn {f, g} => true;
> val it : {f:'a, g:'b} -> bool
:t fn x => fn f => f x;
> val it : 'a -> ('a -> 'b) -> 'b
:t fn (x, y) => x andalso y;
> val it : bool * bool -> bool
:t fn (x, y) => x orelse y;
> val it : bool * bool -> bool
:t fn (x, y) => x implies y;
> val it : bool * bool -> bool
:t fn (x, y) => x < y;
> val it : 'a * 'a -> bool
:t fn (x, y) => x <= y;
> val it : 'a * 'a -> bool
:t fn (x, y) => x > y;
> val it : 'a * 'a -> bool
:t fn (x, y) => x >= y;
> val it : 'a * 'a -> bool
:t fn (x, y) => x = y;
> val it : 'a * 'a -> bool
:t fn (x, y) => x <> y;
> val it : 'a * 'a -> bool
:t fn (x, y) => x + y + 0;
> val it : int * int -> int
:t fn (x, y) => x - y + 0;
> val it : int * int -> int
:t fn (x, y) => x mod y;
> val it : int * int -> int
:t fn (x, y) => x div y;
> val it : int * int -> int
:t fn (x, y) => x / y;
> val it : real * real -> real
:t fn (x, y) => x * y * 1;
> val it : int * int -> int
:t
fn NONE => 0;
> stdIn:1.1-1.13 Warning: match nonexhaustive
>   raised at: stdIn:1.1-1.13
> val it : 'a option -> int

:t
fn (SOME x) => 0;
> stdIn:1.1-1.17 Warning: match nonexhaustive
>   raised at: stdIn:1.1-1.17
> val it : 'a option -> int

:t
fn (SOME x) => x + 1;
> stdIn:1.1-1.21 Warning: match nonexhaustive
>   raised at: stdIn:1.1-1.21
> val it : int option -> int

(* Basic type tests (migrated from MainTest.testType) *)
:t 1;
> val it : int
:t 0e0;
> val it : real
:t 1 + 2;
> val it : int
:t 1 - 2;
> val it : int
:t 1 * 2;
> val it : int
:t 1 div 2;
> val it : int
:t 1 div ~2;
> val it : int
:t 1.0 + ~2.0;
> val it : real
:t 1.0 / ~2.0;
> val it : real
:t "";
> val it : string
:t true andalso false;
> val it : bool
:t if true then 1.0 else 2.0;
> val it : real
:t (1, true);
> val it : int * bool
:t (1, true, false andalso false);
> val it : int * bool * bool
:t (1);
> val it : int
:t ();
> val it : unit
:t {a = 1, b = true};
> val it : {a:int, b:bool}
:t (fn x => x + 1, fn y => y + 1);
> val it : (int -> int) * (int -> int)
:t let val x = 1.0 in x + 2.0 end;
> val it : real
:t
let val x = 1 in
  let val y = 2 in
    x + y
  end
end;
> val it : int
:t
1 + "a";
> 0.0-0.0 Error: Cannot deduce type: conflict: int vs string
>   raised at: 0.0-0.0
:t NONE;
> val it : 'a option
:t SOME 4;
> val it : int option
:t SOME (SOME true);
> val it : bool option option
:t SOME (SOME [1, 2]);
> val it : int list option option
:t SOME (SOME {a=1, b=true});
> val it : {a:int, b:bool} option option
:t {a=1,b=true};
> val it : {a:int, b:bool}
:t {{a=1,b=true} with b=false};
> val it : {a:int, b:bool}

(*) Function types
:t fn x => x + 1;
> val it : int -> int
:t fn x => fn y => x + y;
> val it : int -> int -> int
:t fn x => case x of 0 => 1 | _ => 2;
> val it : int -> int
:t fn x => case x of 0 => "zero" | _ => "nonzero";
> val it : int -> string
:t fn x: int => true;
> val it : int -> bool
:t fn x: int * int => true;
> val it : int * int -> bool
:t fn x: int * string => (false, #2 x);
> val it : int * string -> bool * string

(*) Function tuple types
:t fn (x, y) => (x + 1, y + 1);
> val it : int * int -> int * int
:t fn x => fn (y, z) => x + y + z;
> val it : int -> int * int -> int
:t fn (x, y) => (x + 1, fn z => (x + z, y + z), y);
> val it : int * int -> int * (int -> int * int) * int
:t fn {a = x, b = y, c} => x + y;
> val it : {a:int, b:int, c:'a} -> int

(*) Polymorphic type variables
:t fn _ => 42;
> val it : 'a -> int
:t fn _ => fn _ => 42;
> val it : 'a -> 'b -> int
:t fn x => x;
> val it : 'a -> 'a
:t let fun id x = x in id end;
> val it : 'a -> 'a
:t fun id x = x;
> val id : 'a -> 'a
:t fn x => fn y => x;
> val it : 'a -> 'b -> 'a
:t let fun first x y = x in first end;
> val it : 'a -> 'b -> 'a
:t fun first x y = x;
> val first : 'a -> 'b -> 'a
:t fun second x y = y;
> val second : 'a -> 'b -> 'b
:t fun choose b x y = if b then x else y;
> val choose : bool -> 'a -> 'a -> 'a
:t fun choose b (x, y) = if b then x else y;
> val choose : bool -> 'a * 'a -> 'a

(*) Record types, including duplicate fields
:t map #empno [{empno = 10, name = "Shaggy"}];
> val it : int list
:t {a=1, b=true};
> val it : {a:int, b:bool}
:t {c=1, b=true};
> val it : {b:bool, c:int}
:t {a=1, b=true, a=3};
> stdIn:1.28 Error: duplicate field 'a' in record
>   raised at: stdIn:1.28

(*) Incomplete record type
:t fn (e, job) => e.job = job;
> stdIn:1.29 Error: unresolved flex record (can't tell what fields there are besides #job)
>   raised at: stdIn:1.29

(*) Tuple labels
:t { 1 = true, 2 = 0};
> val it : bool * int
:t {2=0,1=true};
> val it : bool * int
:t {3=0,1=true,11=false};
> val it : {1:bool, 3:int, 11:bool}
:t #1 {1=true,2=0};
> val it : bool
:t #1 (true, 0);
> val it : bool
:t #2 (true, 0);
> val it : int
:t {};
> val it : unit

(*) List types
:t [1];
> val it : int list
:t [[1]];
> val it : int list list
:t [(1, true), (2, false)];
> val it : (int * bool) list
:t 1 :: [2];
> val it : int list
:t 1 :: [2, 3];
> val it : int list
:t [1] :: [[2], [3]];
> val it : int list list
:t 1 :: [];
> val it : int list
:t 1 :: 2 :: [];
> val it : int list
:t fn [] => 0;
> stdIn:1.14-1.24 Warning: match nonexhaustive
>   raised at: stdIn:1.14-1.24
> val it : 'a list -> int

(*) Cannot be typed, since the parameter f is in a monomorphic position
:t fn f => (f true, f 0);
> 0.0-0.0 Error: Cannot deduce type: conflict: int vs bool
>   raised at: 0.0-0.0

(*) Recursive function types
:t
let
  val rec f = fn n => if n = 0 then 1 else n * (f (n - 1))
in
  f 5
end;
> val it : int

let
  val f = fn n => if n = 0 then 1 else n * (f (n - 1))
in
  f 5
end;
> stdIn:2.45 Error: unbound variable or constructor: f
>   raised at: stdIn:2.45

(*) The following should give error but currently does not.
:t let val rec x = 1 and y = 2 in x + y end;
> val it : int
(* sml-nj gives:
stdIn:1.14-1.19 Error: fn expression required on rhs of val rec
stdIn:1.24-1.29 Error: fn expression required on rhs of val rec
stdIn:1.33-1.38 Error: operator and operand do not agree [overload - bad instantiation]
  operator domain: 'Z[OL(+)] * 'Z[OL(+)]
  operand:         ('Y -> 'X) * ('W -> 'V)
  in expression:
    x + y
*)

(*) The following should give error but currently does not.
:t let val rec s = "s" and t = "t" in s ^ t end;
> val it : string
(* sml-nj gives:
stdIn:1.14-1.21 Error: fn expression required on rhs of val rec
stdIn:1.26-1.33 Error: fn expression required on rhs of val rec
stdIn:1.37-1.42 Error: operator and operand do not agree [tycon mismatch]
  operator domain: string * string
  operand:         ('Z -> 'Y) * ('X -> 'W)
  in expression:
    s ^ t
*)

(* Overload tests (migrated from MainTest.testOverload and testOverload1) *)
:t
let
  over foo
  val inst foo = fn i: int => i
  val inst foo = fn b: bool => b
in
  foo false
end;
> val it : bool

:t
let
  over foo
  val inst foo = fn NONE => [] | SOME x => [x]
  val inst foo = fn list => List.null list
in
  foo (SOME 1)
end;
> val it : int list

(* Apply tests (migrated from MainTest.testApply and testApply2) *)
:t hd ["abc"];
> val it : string
:t map (fn x => String.size x) ["abc", "de"];
> val it : int list

(* From/query type tests (migrated from MainTest.testFromType) *)
:t from i in [1];
> val it : int list
:t from i in bag [1];
> val it : int bag
:t from i in (from j in bag [1]);
> val it : int bag
:t from i in (
  from e in bag [{deptno=10}]
  yield e.deptno)
where i > 10
yield i div 10;
> val it : int bag
:t from (i, j) in [("a", 1)];
> val it : {i:string, j:int} list
:t from (i, j) in [(1, 1), (2, 3)];
> val it : {i:int, j:int} list
:t from (x, y) in [(1,2),(3,4),(3,0)] group x + y;
> val it : int list
:t from (x, y) in [(1,2),(3,4),(3,0)] group {sum = x + y};
> val it : {sum:int} list
:t from {c, a, ...} in [{a=1.0,b=true,c=3},{a=1.5,b=true,c=4}];
> val it : {a:real, c:int} list
:t
from p in [{r=1.0, s="a"}]
group p.r compute {x = p.r};
> stdIn:2.24 Error: unbound variable or constructor: p
>   raised at: stdIn:2.24
:t from d in [{a=1,b=true}] yield d.a into sum;
> val it : int

:t
from a in [1], b in [true] yield (b,a) where c;
> stdIn:1.46 Error: unbound variable or constructor: c
>   raised at: stdIn:1.46

:t
from a in [1], b in [true] yield (b,a) where b;
> stdIn:1.46 Error: unbound variable or constructor: b
>   raised at: stdIn:1.46

:t from a in [1], b in [true] yield {b,a} where b;
> val it : {a:int, b:bool} list

:t
from d in [{a=1,b=true}], i in [2] yield {d} yield a;
> stdIn:1.52 Error: unbound variable or constructor: a
>   raised at: stdIn:1.52

:t from d in [{a=1,b=true}], i in [2] yield d yield a;
> stdIn:1.63 Error: unbound variable or constructor: a
>   raised at: stdIn:1.63

:t from {c, a, ...} in [{a=1.0,b=true,c=3},{a=1.5,b=true,c=4}];
> val it : {a:real, c:int} list
:t from i in [1] group i compute count over i;
> val it : {count:int, i:int} list
:t from i in bag [1] group i compute count over i;
> val it : {count:int, i:int} bag
:t from (r, s) in [(1.0, "a")]
  group r compute {x = 1 + sum over size s};
> val it : {r:real, x:int} list
:t from (r, s) in [(1.0, "a")]
  group r compute {x = 1 + sum over size s,
                   y = 0,
                   z = concat over s};
> val it : {r:real, x:int, y:int, z:string} list
:t from p in [{r=1.0, s="a"}]
  group p.r compute {x = r};
> val it : {r:real, x:real} list
:t fn f => from i in [1, 2, 3] join j in [3, 4] on f (i, j) yield i + j;
> val it : (int * int -> bool) -> int list
:t fn f => from i in [1, 2, 3] where f i;
> val it : (int -> bool) -> int list
:t from a in [1], b in [true];
> val it : {a:int, b:bool} list
:t from a in [1], b in [()];
> val it : {a:int, b:unit} list
:t from a in [1], _ in [true];
> val it : int list
:t from a in [1], _ in bag [true];
> val it : int bag
:t from a in [1], _ = ();
> val it : int list
:t from a in bag [1], _ = ();
> val it : int bag

:t from a in [1], b in [true] yield a;
> val it : int list
:t from a in [1], b in [true] yield {a,b};
> val it : {a:int, b:bool} list
:t from a in [1], b in [true] yield {y=a,b};
> val it : {b:bool, y:int} list
:t from a in [1], b in [true] yield {y=a,x=b,z=a};
> val it : {x:bool, y:int, z:int} list
:t from a in [1], b in [true] yield {y=a,x=b,z=a} yield {z,x};
> val it : {x:bool, z:int} list
:t from a in [1], b in [true] yield {y=a,x=b,z=a} yield {z};
> val it : {z:int} list
:t from a in [1], b in [true] yield (b,a);
> val it : (bool * int) list
:t from a in [1], b in [true] yield (b);
> val it : bool list
:t from a in [1], b in [true] yield {b,a} yield a;
> val it : int list
:t from a in [1], b in [true] yield {b,a} where b;
> val it : {a:int, b:bool} list
:t from a in [1], b in [true] yield {b,a,c="c"} where b;
> val it : {a:int, b:bool, c:string} list
:t from a in [1], b in [true] yield (b,a) where true;
> val it : (bool * int) list
:t from d in [{a=1,b=true}], i in [2] yield i;
> val it : int list
:t from d in [{a=1,b=true}], i in [2] yield {d};
> val it : {d:{a:int, b:bool}} list
:t from d in [{a=1,b=true}], i in [2] yield {d} where true;
> val it : {d:{a:int, b:bool}} list
:t from d in [{a=1,b=true}], i in [2] yield {d.a,d.b} yield a;
> val it : int list
:t from d in [{a=1,b=true}], i in [2] yield i yield 3;
> val it : int list
:t from d in [{a=1,b=true}], i in [2] yield d;
> val it : {a:int, b:bool} list
:t from d in [{a=1,b=true}], i in [2] yield {d.a,d.b} yield a;
> val it : int list
:t from d in [{a=1,b=true}], i in [2] yield (d.b, i) yield #1 current;
> val it : bool list
:t from d in [{a=1,b=true}], i in [2] yield {d.a,d.b} order a;
> val it : {a:int, b:bool} list
:t from d in [{a=1,b=true}], i in [2] yield {d.a,d.b} order current.a;
> val it : {a:int, b:bool} list
:t from d in [{a=1,b=true}], i in [2] yield d where true;
> val it : {a:int, b:bool} list
:t from d in [{a=1,b=true}], i in [2] yield d distinct;
> val it : {a:int, b:bool} list
:t from d in [{a=1,b=true}], i in [2] yield d yield d.a;
> val it : int list
:t from d in [{a=1,b=true}], i in [2] yield d order d.a;
> val it : {a:int, b:bool} list
:t from d in [{a=1,b=true}], i in [2] yield i yield 3.0;
> val it : real list

(*) order
:t from e in [{empno=1,deptno=10,name="Fred"},
        {empno=2,deptno=10,name="Jane"}]
  order (e.empno, e.deptno);
> val it : {deptno:int, empno:int, name:string} list
:t from e in [{empno=1,deptno=10,name="Fred"},
        {empno=2,deptno=10,name="Jane"}]
  order {e.deptno, e.empno};
> val it : {deptno:int, empno:int, name:string} list

(*) unorder
:t from d in [{a=1,b=true}], i in [2] unorder;
> val it : {d:{a:int, b:bool}, i:int} bag
:t from d in [{a=1,b=true}], i in [2] unorder unorder;
> val it : {d:{a:int, b:bool}, i:int} bag
:t from d in [{a=1,b=true}], i in [2] unorder order i;
> val it : {d:{a:int, b:bool}, i:int} list

(*) current/ordinal
:t from i in [1,2,3,4,5] yield i + ordinal;
> val it : int list
:t from i in bag [1,2,3,4,5] order DESC i yield i + ordinal;
> val it : int list

:t from i in [1,2,3,4,5] yield substring("hello", 1, current);
> val it : string list

:t
from i in bag [1,2,3,4,5] yield i + ordinal;
> stdIn:1.37-1.44 Error: cannot use 'ordinal' in unordered query
>   raised at: stdIn:1.37-1.44

:t
from i in [1,2,3,4,5] take current;
> stdIn:1.28-1.35 Error: 'current' is only valid in a query
>   raised at: stdIn:1.28-1.35

(*) Records in queries
:t
from d in [{a=1,b=true}] yield d.x;
> stdIn:1.34 Error: no field 'x' in type '{a:int, b:bool}'
>   raised at: stdIn:1.34

:t
from d in [{a=1,b=true}] yield #x d;
> stdIn:1.32-1.34 Error: no field 'x' in type '{a:int, b:bool}'
>   raised at: stdIn:1.32-1.34

(*) with
:t from d in [{a=1,b=true}], i in [2] yield {d with b=false};
> val it : {a:int, b:bool} list

:t from e in [{x=1,y=2},{x=3,y=4},{x=5,y=6}]
  yield {z=e.x}
  where z > 2
  order DESC z
  yield {z=z};
> val it : {z:int} list

:t
let
  val records = from r in bag [1,2]
in
  from r2 in records
end;
> val it : int bag

:t
let
  val records = from r in [{i=1,j=2}]
in
  from r2 in records
end;
> val it : {i:int, j:int} list

(* "map String.size" has type "string list -> int list",
   and therefore the type of "j" is "int". *)
:t
from s in ["ab","c"]
  through j in (map String.size);
> val it : int list

:t
from s in ["ab","c"]
 through j in (map String.size)
 yield j + 2;
> val it : int list

:t
from s in bag ["ab","c"]
  through j in (Bag.map String.size)
  yield j + 2;
> val it : int bag

(*) into
:t from d in [{a=1,b=true}] yield d.a into List.length;
> val it : int
:t from d in bag [{a=1,b=true}] yield d.a into Bag.length;
> val it : int

(*) exists, forall
:t exists d in [{a=1,b=true}] where d.a = 0;
> val it : bool
:t forall d in [{a=1,b=true}] require d.a = 0;
> val it : bool

(*) invalid last step
:t
from d in [{a=1,b=true}] yield d.a into sum yield "a";
> stdIn:1.45-1.54 Error: 'into' step must be last in 'from'
>   raised at: stdIn:1.45-1.54

:t
exists d in [{a=1,b=true}] yield d.a into sum;
> stdIn:1.38-1.46 Error: 'into' step must not occur in 'exists'
>   raised at: stdIn:1.38-1.46

:t
forall d in [{a=1,b=true}] yield d.a into sum;
> stdIn:1.38-1.46 Error: 'into' step must not occur in 'forall'
>   raised at: stdIn:1.38-1.46

:t
forall d in [{a=1,b=true}] yield d.a compute sum over current;
> stdIn:1.38-1.62 Error: 'compute' step must not occur in 'forall'
>   raised at: stdIn:1.38-1.62

:t
forall d in [{a=1,b=true}] yield d.a;
> stdIn:1.28-1.37 Error: last step of 'forall' must be 'require'
>   raised at: stdIn:1.28-1.37

:t
forall d in [{a=1,b=true}];
> stdIn:1.8-1.27 Error: last step of 'forall' must be 'require'
>   raised at: stdIn:1.8-1.27

(*) End type-inference.smli
